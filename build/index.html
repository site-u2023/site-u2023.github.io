<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>OpenWrt Custom Firmware Selector</title>
    
    <!-- „É™„ÇΩ„Éº„Çπ„Éí„É≥„Éà -->
    <link rel="preconnect" href="https://downloads.openwrt.org">
    <link rel="preconnect" href="https://sysupgrade.openwrt.org">
    <link rel="dns-prefetch" href="https://auto-config.site-u.workers.dev">
    <link rel="dns-prefetch" href="https://site-u.pages.dev">

    <!-- „Éâ„Ç≠„É•„É°„É≥„ÉàÊ§úÁ¥¢„Å´Âêë„Åë„Åü„É™„ÇΩ„Éº„Çπ„Éí„É≥„Éà -->
    <link rel="preconnect" href="https://openwrt.org" crossorigin>
    <link rel="dns-prefetch" href="https://openwrt.org">
    
<style>
    /* Âü∫Êú¨„Çπ„Çø„Ç§„É´ */
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        line-height: 1.5;
        margin: 0;
        padding: 0;
        background-color: #f5f5f5;
        color: #000;
    }

    /* PC„Éñ„É©„Ç¶„Ç∂Âêë„ÅëIMEÊäëÊ≠¢ÔºàÂØæÂøú„Éñ„É©„Ç¶„Ç∂„ÅÆ„ÅøÔºâ */
    #models,
    #package-search,
    #package-search-autocomplete input.package-search,
    #command,
    #commands-autocomplete input.command {
        ime-mode: disabled;
    }

    /* ÂÖ¨Âºè‰∫íÊèõ„ÅÆ„Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„Éà */
    #models-autocomplete {
        display: flex;
        padding-top: 0;
        /* padding „ÅØ .device-input-section ÂÜÖ„ÅßË®≠ÂÆö */
    }
    
.container {
        max-width: 720px;
        margin: 0 auto;
        padding: 0 1rem;
    }

    /* Ë¶™„Ç≥„É≥„ÉÜ„Éä„ÅÆÁõ¥‰∏ãË¶ÅÁ¥†„Å´Áµ±‰∏Ä„Éû„Éº„Ç∏„É≥ */
    .container > *:not(:last-child) {
        margin-bottom: 1.5rem;
    }
    
    /* packagesÂÜÖ„ÅÆÁõ¥‰∏ãË¶ÅÁ¥†„ÇÇÂêåÊßò */
    #packages > *:not(:last-child) {
        margin-bottom: 1.5rem;
    }

    h1 {
        font-size: 2.5rem;
        font-weight: 300;
        text-align: center;
        margin-bottom: 1rem;
        color: #007bff;
    }

    .lead {
        font-size: 1.25rem;
        font-weight: 300;
        text-align: center;
        margin-bottom: 2rem;
        color: #6c757d;
    }
    
    .autocomplete {
        position: relative;
        flex-grow: 1;
    }
    
    #models {
        border: 0.06rem solid transparent;
        background-color: #f1f1f1;
        padding: 0.8rem;
        flex-grow: 1;
        margin-right: 0.3125rem;
        border-radius: 0.2rem;
        font-size: inherit;
        color: #495057;
    }
    
    #versions {
        border: 0.06rem solid transparent;
        background-color: #f1f1f1;
        padding: 0.8rem;
        min-width: 8rem;
        border-radius: 0.25rem;
        font-size: inherit;
        color: #495057;
    }

    .autocomplete-items {
        position: absolute;
        border: 1px solid #d4d4d4;
        border-bottom: none;
        border-top: none;
        z-index: 999;  /* 99 „Åã„Çâ 999 „Å´Â¢ó„ÇÑ„Åô */
        top: 100%;
        left: 0;
        right: 0;
        max-height: 18.75rem;
        overflow-y: auto;
        background-color: #fff;
    }

    .autocomplete-items div {
        padding: 0.625rem;
        cursor: pointer;
        background-color: #fff;
        border-bottom: 1px solid #d4d4d4;
    }

    .autocomplete-items div:hover {
        background-color: #e9ecef;
    }

    .autocomplete-active {
        background-color: #00a3e1 !important;
        color: #ffffff;
    }

    /* „Éï„Ç©„Éº„É†Ë¶ÅÁ¥† */
    .form-group {
        margin-bottom: 1rem;
    }

    label {
        display: inline-block;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }

    .form-control {
        display: block;
        width: 100%;
        padding: 0.75rem;
        font-size: 1rem;
        font-weight: 400;
        line-height: 1.25;
        color: #495057;
        background-color: #f1f1f1;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        box-sizing: border-box;
    }

    .form-control:not(textarea) {
        height: 2.75rem;  /* ‚òÖtextarea„ÅØÈô§Â§ñ */
    }

    textarea.form-control {
        height: auto;  /* ‚òÖtextarea„ÅØÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫ */
    }
    
    .form-control:focus {
        color: #495057;
        background-color: #fff;
        border-color: #007bff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }

    .form-control:disabled {
        background-color: #e9ecef;
        color: #495057;
        opacity: 1;
    }

    /* Info/Status „Éú„ÉÉ„ÇØ„Çπ */
    .info {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 0.75rem 1.25rem;
        border-radius: 0.25rem;
    }

    .asu-info {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 0.25rem;
    }

    .asu-error {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 0.25rem;
    }

    /* „Éë„ÉÉ„Ç±„Éº„Ç∏„Çª„ÇØ„Ç∑„Éß„É≥ */
    .packages {
        margin: 1.5rem 0;
    }
    
    /* „Éú„Çø„É≥/„É™„É≥„ÇØ */
    .btn {
        display: inline-block;
        font-weight: 400;
        color: #212529;
        text-align: center;
        cursor: pointer;
        background-color: transparent;
        border: 1px solid transparent;
        padding: 0.375rem 0.75rem;
        font-size: 1rem;
        line-height: 1.5;
        border-radius: 0.25rem;
        transition: all 0.15s ease-in-out;
        text-decoration: none;
        box-shadow: 0 0.06rem 0.3rem 0 rgba(0, 0, 0, 0.2),
                    0 0.125rem 0.125rem 0 rgba(0, 0, 0, 0.14),
                    0 0.19rem 0.06rem -0.125rem rgba(0, 0, 0, 0.12);
    }

    .btn-primary {
        color: #fff;
        background-color: #00a3e1;
        border-color: #00a3e1;
    }

    .btn-primary:hover {
        color: #fff;
        background-color: #038fc6;
        border-color: #038fc6;
    }

    .btn-primary:disabled {
        color: #fff;
        background-color: #00a3e1;
        border-color: #00a3e1;
        opacity: 0.65;
    }

    .custom-link,
    .download-link {
        text-decoration: none;
        border-radius: 0.2rem;
        padding: 0.8rem;
        margin: 1.5rem 0.2rem 0.2rem 0.2rem;  /* ‰∏ä„Éû„Éº„Ç∏„É≥„Çí1.5rem„Å´ */
        font-size: inherit;
        cursor: pointer;
        letter-spacing: 0.05rem;
        display: inline-flex;
        align-items: center;
        line-height: 1;
        box-shadow: 0 0.06rem 0.3rem 0 rgba(0, 0, 0, 0.2),
                    0 0.125rem 0.125rem 0 rgba(0, 0, 0, 0.14),
                    0 0.19rem 0.06rem -0.125rem rgba(0, 0, 0, 0.12);
        color: #fff;
        background-color: #00a3e1;
        width: max-content;
    }

    .custom-link:hover,
    .download-link:hover {
        background-color: #038fc6;
        color: #fff;
    }

    /* flexÊèÉ„Åà„Å†„Åë„ÅßÁµ±‰∏Ä„Åó„ÄÅÂÜÖÈÉ®„Ç¢„Ç§„Ç≥„É≥„ÅØÂÖ¨ÂºèÈÄö„Çä:first-child„Å´Áõ¥Êé•content */
    .custom-link > :first-child,
    .download-link > :first-child {
        height: 1rem;
        width: auto;
        margin-top: 0;
        margin-right: 0.9375rem;
        content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM12 7a1 1 0 0 1 1 1v4h3l-4 4-4-4h3V8a1 1 0 0 1 1-1z' fill='%23fff'/%3E%3C/svg%3E");
    }

    /* „Ç´„Çπ„Çø„É†„Çª„ÇØ„Ç∑„Éß„É≥ */
    .aios-section {
        margin: 0;
        padding: 1rem;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
    }

    .aios-config {
        margin-top: 1rem;
    }
    
    #package-selector-config {
        margin-top: 1rem;
    }
    
    .form-row {
        display: flex;
        flex-wrap: wrap;
        margin-right: -0.3125rem;
        margin-left: -0.3125rem;
    }

    .form-row > .form-group {
        padding-right: 0.3125rem;
        padding-left: 0.3125rem;
        flex: 1;
    }

    .radio-group {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
    }

    .form-check {
        position: relative;
        display: block;
        padding-left: 1.25rem;
    }

    .form-check-input {
        position: absolute;
        margin-top: 0.3rem;
        margin-left: -1.25rem;
    }

    .form-check-label {
        margin-bottom: 0;
    }

    .conditional-section {
        padding: 1rem;
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 0.25rem;
        display: none;
    }

    h5.section-title {
        font-size: 1rem;
        font-weight: 500;
        margin-top: 0;
        margin-bottom: 0.75rem;
        color: #495057;
    }
    
    .text-muted {
        color: #6c757d;
    }

    .small {
        font-size: 0.875rem;
    }

    /* „Éó„É≠„Ç∞„É¨„ÇπË°®Á§∫ */
    .build-progress {
        margin: 1rem 0;
        padding: 1rem;
        background-color: inherit;
        border: 1px solid #2196f3;
        border-radius: 0.25rem;
        display: none;
    }

    .progress {
        width: 100%;
        height: 1rem;
        background-color: #e9ecef;
        border-radius: 0.25rem;
        overflow: hidden;
        margin-top: 0.5rem;
    }

    .progress-bar {
        height: 100%;
        background-color: #007bff;
        transition: width 0.3s ease;
    }

    /* „Éë„ÉÉ„Ç±„Éº„Ç∏ÈÅ∏Êäû */
    .package-category {
        margin-top: 0; 
        margin-bottom: 1.5rem;
        padding: 0.5rem 1rem 1rem 1rem;
        background-color: #fff;
        border: 1px solid #e9ecef;
        border-radius: 0.25rem;
    }

/* h4„Çø„Ç∞„ÇíÂÖ®ÈÉ®Âêå„Åò„Çπ„Çø„Ç§„É´„Å´Áµ±‰∏Ä */
    h4 {
        margin-top: 1rem;
        margin-bottom: 0.75rem;
        padding: 0.75rem 1rem;
        background-color: #fff;
        border: 1px solid #e9ecef;
        border-radius: 0.25rem;
        font-size: 1.1rem;
        font-weight: 500;
    }

    .package-category-description {
        font-size: 0.9rem;
        color: #6c757d;
        margin: 0.5rem 0 1rem 0;
        font-style: italic;
    }
    
    .package-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: flex-start;
    }

    .package-item {
        width: calc(50% - 0.5rem);
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding: 0.25rem 0;
        margin-bottom: 0.5rem;
    }

    .package-item .form-check {
        margin-bottom: 0;
        flex: 1;
    }

    .package-link {
        color: #007bff;
        text-decoration: none;
        font-size: 1rem;
    }

    .package-link:hover {
        color: #0056b3;
        text-decoration: underline;
    }

    .package-description {
        font-size: 0.9rem;
        color: #6c757d;
        margin-left: 1.25rem;
        margin-top: 0.1rem;
    }

    .package-hidden {
        opacity: 0.7;
        font-style: italic;
    }

    .package-dependent {
        margin-left: 1.5rem;
        font-size: 0.9rem;
        color: #6c757d;
        display: flex;
        align-items: center;
    }

    .package-dependent::before {
        content: "‚Ü≥";
        display: inline-block;
        margin-right: 0.25rem;
        color: #007bff;
    }

    /* ÂÖ¨Âºè„É¨„Ç§„Ç¢„Ç¶„Éà */
    .row {
        display: flex;
        line-height: 1.5;
        padding-left: 1.5rem;
        overflow: hidden;
    }

    .col1 {
        display: inline-block;
        width: 6rem;
        color: #6c757d;
    }

    .col1:after {
        content: ":";
    }

    .col2 {
        display: inline-block;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .col2 a {
        margin-right: 1rem;
    }

    /* „Ç¢„Ç§„Ç≥„É≥ */
    #image-info {
        width: 1.25rem;
        content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='48px' viewBox='0 -2 24 24' width='48px' fill='%23000000'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z'/%3E%3C/svg%3E");
    }

    #image-folder {
        width: 1.25rem;
        content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='48px' viewBox='0 -2 24 24' width='48px' fill='%23000000'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z'/%3E%3C/svg%3E");
    }

    #image-link {
        width: 1.25rem;
        content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='24px' viewBox='0 -2 24 24' width='24px' fill='%23000000'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='m 6.3 17.7 c -1.2 -1.2 -1.2 -3.2 0 -4.4 L 9.10 10.5 7.8 9 4.9 12 c -2 2 -2 5 0 7 2 2 5 2 7 0 l 2.8 -2.8 -1.3 -1.3 -2.8 2.8 c -1.2 1.2 -3.2 1.2 -4.4 0 z M 10 15.5 15.5 10 14 8.5 8.5 14 Z M 12 4.9 9.18 7.8 10.5 9.1 13.4 6.3 c 1.21 -1.2 3.2 -1.2 4.4 0 1.2 1.2 1.2 3.2 0 4.4 l -2.8 2.8 1.3 1.3 2.8 -2.8 c 2 -2 2 -5 0 -7 -2 -2 -5 -2 -7 0 z'/%3E%3C/svg%3E");
    }

    .images {
        margin: 1.5rem 0;
    }

    /* summary„ÅÆÈöéÂ±§Ë°®Á§∫ */
    #asu > summary {
        font-size: 1.3rem;
        font-weight: 500;
        cursor: pointer;
    }

    #use-package-selector-details > summary,
    #use-aios-config-details > summary {
        font-size: 1.2rem;
        font-weight: 500;
        cursor: pointer;
    }
    
    /* ÁâπÊÆä„Éï„Ç£„Éº„É´„Éâ */
    #mape-gua-section {
        margin-top: 1rem;
    }

    /* „Éá„Éê„Ç§„ÇπÂÖ•Âäõ„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Çπ„Çø„Ç§„É´ */
    .device-input-section {
        margin: 0;
        background-color: #252528;
        border: 1px solid #444;
        border-radius: 0.25rem;
        overflow: visible;
        position: relative;
    }
    
    .device-input-section #models-autocomplete {
        padding: 1rem;
        background-color: transparent;
    }
    
    /* „Ç§„É≥„Éó„ÉÉ„Éà„Éú„ÉÉ„ÇØ„ÇπËá™‰Ωì„Çí„Çà„ÇäÊøÉ„Åè */
    .device-input-section #models {
        background-color: #1a1a1d !important;  /* „Åï„Çâ„Å´ÊøÉ„ÅÑËâ≤ */
        border-color: #555;
    }
    
    .device-input-section #versions {
        background-color: #1a1a1d !important;  /* „Åï„Çâ„Å´ÊøÉ„ÅÑËâ≤ */
        border-color: #555;
    }
    
/* „É©„Ç§„Éà„É¢„Éº„ÉâÂØæÂøú */
    @media (prefers-color-scheme: light) {
        .device-input-section {
            background-color: #e9ecef;
            border-color: #dee2e6;
        }
        
        .device-input-section #models,
        .device-input-section #versions {
            background-color: #ffffff !important;
            border-color: #ced4da;
        }
    }
    
    details {
        margin: 0;
        padding: 0;
    }

    details > summary {
        cursor: pointer;
        padding: 0.5rem 0;
        margin: 0;
        outline: none;
    }

    details[open] > summary {
        margin-bottom: 0.5rem;
    }

    #use-package-selector-details summary,
    #use-aios-config-details summary {
        font-weight: 500;
        font-size: 1.1rem;
    }

    /* Installed Packages„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„ÅÆÊúÄÂàù„ÅÆË¶ÅÁ¥†„ÅÆ„Éû„Éº„Ç∏„É≥Ë™øÊï¥ */
    #package-selector-config > *:first-child {
        margin-top: 0 !important;
    }

    /* „É¨„Çπ„Éù„É≥„Ç∑„Éñ */
    @media (max-width: 576px) {
        #models-autocomplete {
            flex-direction: column;
        }
        
        #versions {
            margin-top: 0.5rem;
        }
        
        #models {
            margin-right: 0;
        }
        
        .form-row {
            flex-direction: column;
        }
        
        .radio-group {
            flex-direction: column;
            gap: 0.5rem;
        }

        .package-item {
            width: 100%;
        }
    }

    /* „ÉÄ„Éº„ÇØ„É¢„Éº„Éâ */
    @media (prefers-color-scheme: dark) {
        body {
            background-color: #18181b;
            color: #d0d0d0;
        }
        
        #models,
        #versions {
            background-color: #313135;
            color: #d0d0d0;
        }
        
        .form-control {
            background-color: #313135;
            color: #d0d0d0;
            border-color: #555;
        }
        
        .form-control:focus {
            background-color: #313135;
            color: #d0d0d0;
            border-color: #0080b3;
            box-shadow: 0 0 0 0.2rem rgba(0, 128, 179, 0.25);
        }
        
        .form-control:disabled {
            background-color: #313135;
            color: #d0d0d0;
            border-color: #444;
        }
        
        .autocomplete-items {
            background-color: #252528;
            border-color: #444;
        }
        
        .autocomplete-items div {
            background-color: #252528;
            border-color: #444;
        }
        
        .autocomplete-items div:hover,
        .autocomplete-active {
            background-color: #0080b3 !important;
            color: #fff;
        }
        
        .info {
            background-color: #1d4046;
            border-color: #2a5a61;
            color: #d0d0d0;
        }
        
        .asu-info {
            background-color: #1d4046;
            border-color: #2a5a61;
            color: #d0d0d0;
        }
        
        .asu-error {
            background-color: #601b21;
            border-color: #721c24;
            color: #d0d0d0;
        }
        
        .aios-section {
            background-color: #313135;
            border-color: #444;
        }

        .aios-config {
            background-color: #252528;
            border-color: #444;
        }

        h4 {
            background-color: #252528;
            border-color: #444;
            color: #d0d0d0;
        }
        
        .package-category {
            background-color: #252528;
            border-color: #444;
        }
        
        .conditional-section {
            background-color: #313135 !important;
            border-color: #444 !important;
        }

        h5.section-title {
            color: #d0d0d0;
        }
        
        #asu-stderr,
        #asu-stdout {
            background-color: #252528 !important;
            color: #d0d0d0;
        }
        
        #image-info,
        #image-folder,
        #image-link {
            filter: invert(100%) sepia(9%) saturate(261%) hue-rotate(281deg) brightness(117%) contrast(100%);
        }
    } /* close @media (prefers-color-scheme: dark) */
</style>

</head>

<body>
    <div class="container">
        <h1>OpenWrt Custom Firmware Selector</h1>
        <p class="lead">Firmware images are built via the official 
            <a href="https://sysupgrade.openwrt.org" target="_blank" rel="noopener noreferrer">
                ASU server
            </a>.
        </p>
        <p class="server-info" style="text-align: center;">Enter your device model and choose a build</p>
    <div class="device-input-section">
            <div id="models-autocomplete" class="autocomplete">
                <input type="text"
                  id="models" 
                  placeholder="Type device model"
                  lang="en"
                  inputmode="latin"
                  autocomplete="off"
                  spellcheck="false"
                  autocapitalize="off"
                  autofocus>
                <select id="versions">
                    <option value="" disabled selected>Loading versions...</option>
                </select>
            </div>
        </div>

        <div id="info" class="info" style="display: none;">
            <!-- Content will be dynamically generated -->
        </div>

        <div id="packages" class="packages" style="display: none;">
            <!-- <details id="asu">
                <summary>Customize installed packages and/or first boot script</summary> -->
                <!-- „Éë„ÉÉ„Ç±„Éº„Ç∏„Çª„É¨„ÇØ„Çø„Éº„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="aios-section">
                    <details id="use-package-selector-details">
                        <summary>Installed Packages</summary>
                        
                        <div id="package-selector-config">
                        <!-- „Éë„ÉÉ„Ç±„Éº„Ç∏Ê§úÁ¥¢„Éú„ÉÉ„ÇØ„Çπ -->
                        <div class="package-category">
                          <h4>Package Search</h4>
                          <div class="package-category-description">
                            Select extra packages to install. They'll be added to the list below.
                          </div>  
                          <div id="package-search-autocomplete" class="autocomplete">
                              <input type="text"
                                id="package-search"
                                placeholder="Type package name"
                                lang="en"
                                inputmode="latin"
                                autocomplete="off"
                                spellcheck="false"
                                autocapitalize="off"
                                class="form-control">
                          </div>
                        </div>
                        <ul id="installed-packages">
                          <!-- „Éë„ÉÉ„Ç±„Éº„Ç∏‰∏ÄË¶ß„Åå„Åì„Åì„Å´ÁîüÊàê„Åï„Çå„Çã -->
                        </ul>
                        
                        <div id="package-categories">
                            <!-- „Ç´„ÉÜ„Ç¥„É™„Éº„Å®„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØÂãïÁöÑ„Å´ÁîüÊàê„Åï„Çå„Çã -->
                        </div>
                        
                        <div class="form-group" style="margin-top: 1.5rem;">
                            <h4>Packages</h4>
                            <label for="asu-packages" style="display: none;">Packages</label>
                            <textarea id="asu-packages" class="form-control" rows="6" placeholder="luci&#10;luci-ssl&#10;-wpad-basic-wolfssl&#10;wpad-wolfssl"></textarea>
                        </div>
                    </div>
                </div>

                <!-- setup.shË®≠ÂÆö„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="aios-section">
                    <details id="use-aios-config-details">
                        <summary>Script to run on first boot (uci-defaults)</summary>
                        
                        <div id="aios-config">
                            <!-- ÂÖ¨Âºè„Éâ„Ç≠„É•„É°„É≥„Éà„É™„É≥„ÇØ -->
                            <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; padding: 0.75rem; margin-bottom: 1rem; border-radius: 0.25rem;">
                                üìñ <a href="https://openwrt.org/docs/guide-user/installation/sysupgrade.owut#using_a_uci-defaults_script" target="_blank" rel="noopener" style="color: #0c5460; font-weight: 500;">Using a uci-defaults script</a> - Official documentation and limitations
                            </div>
                                
                            <!-- Commands -->
                            <div class="package-category">
                              <h4>Add commands</h4>
                              <div class="package-category-description">
                                Add custom shell commands that run on first boot.
                                <a href="https://openwrt.org/docs/guide-user/base-system/uci" target="_blank" rel="noopener">
                                    The UCI system
                                </a>
                              </div>  
                              <div id="commands-autocomplete" class="autocomplete">
                                  <input type="text"
                                    id="command"
                                    placeholder="Type commands"
                                    lang="en"
                                    inputmode="latin"
                                    autocomplete="off"
                                    spellcheck="false"
                                    autocapitalize="off"
                                    class="form-control">
                              </div>
                            </div>

                            <h4>Basic Configuration</h4>
                        
                        <!-- 1Ë°åÁõÆ: Language „Å® Country -->
                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-language">Language</label>
                                <select id="aios-language" class="form-control">
                                    <option value="en">English</option>
                                    <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ© (Arabic)</option>
                                    <option value="bg">–ë—ä–ª–≥–∞—Ä—Å–∫–∏ (Bulgarian)</option>
                                    <option value="ca">Catal√† (Catalan)</option>
                                    <option value="cs">ƒåe≈°tina (Czech)</option>
                                    <option value="da">Dansk (Danish)</option>
                                    <option value="de">Deutsch (German)</option>
                                    <option value="el">ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ (Greek)</option>
                                    <option value="es">Espa√±ol (Spanish)</option>
                                    <option value="fi">Suomi (Finnish)</option>
                                    <option value="fr">Fran√ßais (French)</option>
                                    <option value="he">◊¢◊ë◊®◊ô◊™ (Hebrew)</option>
                                    <option value="hu">Magyar (Hungarian)</option>
                                    <option value="it">Italiano (Italian)</option>
                                    <option value="ja">Êó•Êú¨Ë™û (Japanese)</option>
                                    <option value="ko">ÌïúÍµ≠Ïñ¥ (Korean)</option>
                                    <option value="lt">Lietuvi≈≥ (Lithuanian)</option>
                                    <option value="ms">Bahasa Melayu (Malay)</option>
                                    <option value="nl">Nederlands (Dutch)</option>
                                    <option value="no">Norsk (Norwegian)</option>
                                    <option value="pl">Polski (Polish)</option>
                                    <option value="pt">Portugu√™s (Portuguese)</option>
                                    <option value="pt_br">Portugu√™s do Brasil (Portuguese Brazil)</option>
                                    <option value="ro">Rom√¢nƒÉ (Romanian)</option>
                                    <option value="ru">–†—É—Å—Å–∫–∏–π (Russian)</option>
                                    <option value="sk">Slovenƒçina (Slovak)</option>
                                    <option value="sv">Svenska (Swedish)</option>
                                    <option value="tr">T√ºrk√ße (Turkish)</option>
                                    <option value="uk">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (Ukrainian)</option>
                                    <option value="vi">Ti·∫øng Vi·ªát (Vietnamese)</option>
                                    <option value="zh_cn">ÁÆÄ‰Ωì‰∏≠Êñá (Chinese Simplified)</option>
                                    <option value="zh_tw">ÁπÅÈ´î‰∏≠Êñá (Chinese Traditional)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="aios-country">Country</label>
                                <input type="text" id="aios-country" class="form-control" placeholder="00" maxlength="2">
                                <small class="form-text text-muted">2-letter country code (e.g., US, JP)</small>
                            </div>
                        </div>

                        <!-- 2Ë°åÁõÆ: Timezone „Å® Zone name -->
                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-timezone">Timezone</label>
                                <input type="text" id="aios-timezone" class="form-control" placeholder="UTC">
                            </div>
                            <div class="form-group">
                                <label for="aios-zonename">Zone name</label>
                                <input type="text" id="aios-zonename" class="form-control" placeholder="UTC">
                                <small class="form-text text-muted">Optional: e.g., America/New_York, Asia/Tokyo</small>
                            </div>
                        </div>

                        <!-- Device name„Å®Root password -->
                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-device-name">Device name</label>
                                <input type="text" id="aios-device-name" class="form-control" placeholder="OpenWrt">
                            </div>
                            <div class="form-group">
                                <label for="aios-root-password">Root password</label>
                                <input type="password" id="aios-root-password" class="form-control" placeholder="8+ characters">
                                <small class="form-text text-muted">Leave empty to disable password authentication</small>
                            </div>
                        </div>

                        <!-- LAN IPv4/IPv6„Ç¢„Éâ„É¨„Çπ -->
                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-lan-ipv4">LAN IPv4 Address</label>
                                <input type="text" id="aios-lan-ipv4" class="form-control" placeholder="192.168.1.1" value="192.168.1.1">
                            </div>
                            <div class="form-group">
                                <label for="aios-lan-ipv6">LAN IPv6 Address</label>
                                <input type="text" id="aios-lan-ipv6" class="form-control" placeholder="fd00::1/64">
                                <small class="form-text text-muted">Optional: e.g., fd00::1/64</small>
                            </div>
                        </div>

                        <!-- SSH Interface „Å® Flow Offloading -->
                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-ssh-interface">SSH Interface</label>
                                <input type="text" id="aios-ssh-interface" class="form-control" placeholder="lan" value="lan">
                                <small class="form-text text-muted">Network interface for SSH access</small>
                            </div>
                            <div class="form-group">
                                <label for="aios-ssh-port">SSH Port</label>
                                <input type="number" id="aios-ssh-port" class="form-control" placeholder="22" value="22" min="1" max="65535">
                                <small class="form-text text-muted">Port number for SSH access</small>
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-flow-offloading">Flow offloading type</label>
                                <select id="aios-flow-offloading" class="form-control">
                                    <option value="">Disabled</option>
                                    <option value="software">Software flow offloading</option>
                                    <option value="hardware">Hardware flow offloading</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="aios-backup-path">Restore Backup Path</label>
                                <input type="text" id="aios-backup-path" class="form-control" placeholder="/root/backup.tar.gz" value="/root/backup.tar.gz">
                                <small class="form-text text-muted">Path to backup file for restore</small>
                            </div>
                        </div>
                        
                        <h4>Wi‚ÄëFi Configuration</h4>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="aios-wifi-ssid">Wi‚ÄëFi SSIDs (Base name)</label>
                                <input type="text" id="aios-wifi-ssid" class="form-control" placeholder="OpenWrt">
                                <small class="form-text text-muted">Auto-creates SSID per interface with band suffix</small>
                            </div>
                            <div class="form-group">
                                <label for="aios-wifi-password">Wi‚ÄëFi Password (Shared)</label>
                                <input type="password" id="aios-wifi-password" class="form-control" placeholder="8+ characters">
                                <small class="form-text text-muted">Same password for all SSIDs</small>
                            </div>
                        </div>

                        <h4>Internet Connection</h4>
                        <div class="form-group">
                            <label>Connection mode</label>
                            <div class="radio-group">
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="connectionMode" id="mode-auto" value="auto" checked>
                                    <label class="form-check-label" for="mode-auto">Auto (Recommended)</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="connectionMode" id="mode-manual" value="manual">
                                    <label class="form-check-label" for="mode-manual">Manual</label>
                                </div>
                            </div>
                        </div>

                        <div id="manual-connection-section" class="conditional-section">
                            <div class="form-group">
                                <label>Connection type</label>
                                <div class="radio-group">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="connectionType" id="conn-dhcp" value="dhcp" checked>
                                        <label class="form-check-label" for="conn-dhcp">DHCP</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="connectionType" id="conn-pppoe" value="pppoe">
                                        <label class="form-check-label" for="conn-pppoe">PPPoE</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="connectionType" id="conn-dslite" value="dslite">
                                        <label class="form-check-label" for="conn-dslite">DS-Lite</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="connectionType" id="conn-mape" value="mape">
                                        <label class="form-check-label" for="conn-mape">MAP-E</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="connectionType" id="conn-ap" value="ap">
                                        <label class="form-check-label" for="conn-ap">AP</label>
                                    </div>
                                </div>
                            </div>

                            <!-- DHCPË®≠ÂÆö -->
                            <div id="dhcp-section" class="conditional-section">
                                <h5 class="section-title">DHCP Configuration</h5>
                                <div class="form-group">
                                    <small class="text-muted">No additional configuration required. Router will obtain IP address automatically from ISP.</small>
                                </div>
                            </div>

                            <!-- PPPoEË®≠ÂÆö -->
                            <div id="pppoe-section" class="conditional-section">
                                <h5 class="section-title">PPPoE Configuration</h5>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="pppoe-username">PPPoE username</label>
                                        <input type="text" id="pppoe-username" class="form-control" placeholder="Username">
                                    </div>
                                    <div class="form-group">
                                        <label for="pppoe-password">PPPoE password</label>
                                        <input type="password" id="pppoe-password" class="form-control" placeholder="Password">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- DS-LiteË®≠ÂÆö -->
                            <div id="dslite-section" class="conditional-section">
                                <h5 class="section-title">DS-Lite Configuration</h5>
                                
                                <div class="form-group">
                                    <div class="radio-group">
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="dsliteMode" id="dslite-auto" value="auto">
                                            <label class="form-check-label" for="dslite-auto">Auto (Recommended)</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="dsliteMode" id="dslite-manual" value="manual">
                                            <label class="form-check-label" for="dslite-manual">Manual</label>
                                        </div>
                                    </div>
                                    <small class="text-muted" id="dslite-mode-hint">Auto: Use ISP-detected AFTR address | Manual: Specify AFTR settings manually</small>
                                </div>

                                <div id="dslite-manual-config" class="conditional-section">
                                    <div class="form-group">
                                        <label for="dslite-aftr-type">AFTR Type</label>
                                        <select id="dslite-aftr-type" class="form-control" onchange="applyInitialsFromApi('dslite')">
                                            <option value="transix">gw.transix.jp</option>
                                            <option value="xpass">gw.xpass.jp</option>
                                            <option value="v6option">gw.v6option.jp</option>
                                        </select>
                                    </div>

                                    <div class="form-group">
                                        <label for="dslite-area">Region</label>
                                        <select id="dslite-area" class="form-control" onchange="applyInitialsFromApi('dslite')">
                                            <option value="east">East Japan</option>
                                            <option value="west">West Japan</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label for="dslite-aftr-address">AFTR IPv6 Address</label>
                                    <input type="text" id="dslite-aftr-address" class="form-control" placeholder="2404:8e00::feed:100" value="">
                                    <small class="form-text text-muted">Auto mode: Set from ISP detection | Manual mode: Set based on AFTR type and region</small>
                                </div>
                            </div>
                            
                            <!-- MAP-EË®≠ÂÆö -->
                            <div id="mape-manual-section" class="conditional-section">
                                <h5 class="section-title">MAP-E Configuration</h5>
                                <div class="form-group">
                                    <div class="radio-group">
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="mapeType" id="mape-auto" value="auto">
                                            <label class="form-check-label" for="mape-auto">Auto (Recommended)</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="mapeType" id="mape-gua" value="gua">
                                            <label class="form-check-label" for="mape-gua">GUA</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="mapeType" id="mape-pd" value="pd">
                                            <label class="form-check-label" for="mape-pd">PD</label>
                                        </div>
                                    </div>
                                    <small class="text-muted">
                                        <strong>Auto-detect</strong>: Automatically retrieve MAP-E technical information and configure with GUA mode (1G/10G compatible)<br>
                                        <strong>Manual selection</strong>: For troubleshooting or specific requirements only
                                    </small>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="mape-br">BR (Border Relay)</label>
                                        <input type="text" id="mape-br" class="form-control" placeholder="2001:db8::1">
                                    </div>
                                    <div class="form-group">
                                        <label for="mape-ealen">EA-len</label>
                                        <input type="number" id="mape-ealen" class="form-control" placeholder="16" min="0" max="48">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="mape-ipv4-prefix">IPv4 Prefix</label>
                                        <input type="text" id="mape-ipv4-prefix" class="form-control" placeholder="192.0.2.0">
                                    </div>
                                    <div class="form-group">
                                        <label for="mape-ipv4-prefixlen">IPv4 Prefix Length</label>
                                        <input type="number" id="mape-ipv4-prefixlen" class="form-control" placeholder="24" min="1" max="32">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="mape-ipv6-prefix">IPv6 Prefix</label>
                                        <input type="text" id="mape-ipv6-prefix" class="form-control" placeholder="2001:db8:8000::">
                                    </div>
                                    <div class="form-group">
                                        <label for="mape-ipv6-prefixlen">IPv6 Prefix Length</label>
                                        <input type="number" id="mape-ipv6-prefixlen" class="form-control" placeholder="32" min="1" max="128">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="mape-psid-offset">PSID Offset</label>
                                        <input type="number" id="mape-psid-offset" class="form-control" placeholder="4" min="0" max="16">
                                    </div>
                                    <div class="form-group">
                                        <label for="mape-psidlen">PSID Length</label>
                                        <input type="number" id="mape-psidlen" class="form-control" placeholder="6" min="0" max="16">
                                    </div>
                                </div>

                                <div id="mape-gua-section" class="form-group" style="display: none;">
                                    <label for="mape-gua-prefix">GUA Prefix</label>
                                    <input type="text" id="mape-gua-prefix" class="form-control" placeholder="2400:4151:80e2:7500::/64">
                                    <small class="form-text text-muted">IPv6 Global Unicast Address prefix for 1G/10G line compatibility</small>
                                </div>
                            </div>
                            
                            <!-- AP√®¬®¬≠√•¬Æ≈° -->
                            <div id="ap-section" class="conditional-section">
                                <h5 class="section-title">AP Configuration</h5>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="ap-ip-address">IP Address</label>
                                        <input type="text" id="ap-ip-address" class="form-control" value="192.168.1.2">
                                    </div>
                                    <div class="form-group">
                                        <label for="ap-gateway">Gateway</label>
                                        <input type="text" id="ap-gateway" class="form-control" value="192.168.1.1">
                                    </div>
                                </div>
                            </div>
                        </div>
    
                        <div class="form-group" id="isp-detection-group">
                            <label>ISP Detection Status</label>
                            <div id="isp-info-display" class="info" style="margin-bottom: 0;">
                                <div id="isp-status-message">ISP information will be detected when configuration is opened</div>
                                <div id="isp-technical-info" style="font-family: monospace; font-size: 0.9em; margin-top: 0.5rem; display: none;"></div>
                            </div>
                        </div>
                        
                        <div class="form-group" style="margin-top: 1.5rem;">
                            <h4>Scripts</h4>
                            <label for="uci-defaults-content" style="display: none;">Scripts</label>
                            <textarea id="uci-defaults-content" class="form-control" rows="6" placeholder="#!/bin/sh&#10;&#10;# Your custom script here&#10;# This area is for manual editing - configuration wizard will not overwrite your changes"></textarea>
                        </div>
                    </details>  <!-- use-aios-config-details „ÇíÈñâ„Åò„Çã -->
                </div>

                <a id="request-build" href="javascript:buildAsuRequest()" class="custom-link">
                    <span></span>
                    <span>REQUEST BUILD</span>
                </a>
            <!-- </details> -->  <!-- asu „ÇíÈñâ„Åò„Çã -->
        </div>

        <!-- „Éó„É≠„Ç∞„É¨„ÇπË°®Á§∫ -->
        <div id="build-progress" class="build-progress">
            <div id="build-message">Building image...</div>
            <div class="progress">
                <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
            </div>
        </div>

        <div id="asu-buildstatus" class="asu-info" style="display: none;">
            <span></span>
        </div>

        <div id="asu-log" style="display: none;">
            <details>
                <summary>STDERR</summary>
                <pre id="asu-stderr" style="background: #f8f8f8; padding: 10px; overflow: auto; max-height: 300px;"></pre>
            </details>
            <details>
                <summary>STDOUT</summary>
                <pre id="asu-stdout" style="background: #f8f8f8; padding: 10px; overflow: auto; max-height: 300px;"></pre>
            </details>
        </div>

        <div id="download-links"></div>
    </div>

    <script>

// setup.sh„ÉÜ„É≥„Éó„É¨„Éº„Éà
const SETUP_SH_TEMPLATE = `#!/bin/sh
LAN_DEF="$(uci -q get network.lan.device || echo lan)"
WAN_DEF="$(uci -q get network.wan.device || echo wan)"
MAP_NAME="mape"
MAP6_NAME="mape6"
DSLITE_NAME="dslite"
DSLITE6_NAME="dslite6"
AP_NAME="ap"
AP6_NAME="ap6"
# BEGIN_VARIABLE_DEFINITIONS
# END_VARIABLE_DEFINITIONS
exec >/tmp/setup.log 2>&1
[ -n "\${device_name}" ] && uci set system.@system[0].hostname="\${device_name}"
[ -n "\${root_password}" ] && printf "%s\n%s\n" "\${root_password}" "\${root_password}" | passwd >/dev/null
[ -n "\${lan_ip_address}" ] && uci set network.lan.ipaddr="\${lan_ip_address}"
[ -n "\${lan_ipv6_address}" ] && uci set network.lan.ip6addr="\${lan_ipv6_address}"
[ -n "\${language}" ] && uci set system.@system[0].language="\${language}"
[ -n "\${timezone}" ] && uci set system.@system[0].timezone="\${timezone}"
[ -n "\${zonename}" ] && uci set system.@system[0].zonename="\${zonename}"
[ -n "\${ssh_interface}" ] && uci set dropbear.@dropbear[0].Interface="\${ssh_interface}"
[ -n "\${ssh_port}" ] && uci set dropbear.@dropbear[0].Port="\${ssh_port}"
[ "\${flow_offloading_type}" = "software" ] && uci set firewall.@defaults[0].flow_offloading='1'
[ "\${flow_offloading_type}" = "hardware" ] && { uci set firewall.@defaults[0].flow_offloading='1'; uci set firewall.@defaults[0].flow_offloading_hw='1'; }
[ -n "\${wlan_name}" ] && [ -n "\${wlan_password}" ] && {
    for radio in $(uci -q show wireless | grep "wireless\.radio[0-9]*=" | cut -d. -f2 | cut -d= -f1); do
        uci set wireless.\${radio}.disabled='0'
        uci set wireless.\${radio}.country="\${country:-00}" 2>/dev/null
        band=$(uci -q get wireless.\${radio}.band)
        case "\${band}" in
            2g) suffix="-2g"; encryption='sae-mixed' ;;
            5g) suffix="-5g"; encryption='sae-mixed' ;;
            6g) suffix="-6g"; encryption='sae' ;;
            *) suffix=""; encryption='sae-mixed' ;;
        esac
        iface="default_\${radio}"
        [ -n "$(uci -q get wireless.\${iface})" ] && {
            uci set wireless.\${iface}.disabled='0'
            uci set wireless.\${iface}.encryption="\${encryption}"
            uci set wireless.\${iface}.ssid="\${wlan_name}\${suffix}"
            uci set wireless.\${iface}.key="\${wlan_password}"
        }
    done
}
[ -n "\${pppoe_username}" ] && [ -n "\${pppoe_password}" ] && {
    uci set network.wan.proto='pppoe'
    uci set network.wan.username="\${pppoe_username}"
    uci set network.wan.password="\${pppoe_password}"
}
[ -n "\${dslite_aftr_address}" ] && {
    uci set network.wan.disabled='1'
    uci set network.wan.auto='0'
    uci set network.wan6.disabled='1'
    uci set network.wan6.auto='0'
    uci set network.\${DSLITE6_NAME}=interface
    uci set network.\${DSLITE6_NAME}.proto='dhcpv6'
    uci set network.\${DSLITE6_NAME}.device="\${WAN_DEF}"
    uci set network.\${DSLITE6_NAME}.reqaddress='try'
    uci set network.\${DSLITE6_NAME}.reqprefix='auto'
    uci set network.\${DSLITE_NAME}=interface
    uci set network.\${DSLITE_NAME}.proto='dslite'
    uci set network.\${DSLITE_NAME}.peeraddr="\${dslite_aftr_address}"
    uci set network.\${DSLITE_NAME}.tunlink="\${DSLITE6_NAME}"
    uci set network.\${DSLITE_NAME}.mtu='1460'
    uci set network.\${DSLITE_NAME}.encaplimit='ignore'
    uci set dhcp.\${DSLITE6_NAME}=dhcp
    uci set dhcp.\${DSLITE6_NAME}.interface="\${DSLITE6_NAME}"
    uci set dhcp.\${DSLITE6_NAME}.master='1'
    uci set dhcp.\${DSLITE6_NAME}.ra='relay'
    uci set dhcp.\${DSLITE6_NAME}.dhcpv6='relay'
    uci set dhcp.\${DSLITE6_NAME}.ndp='relay'
    uci set dhcp.\${DSLITE6_NAME}.ignore='1'
    uci set dhcp.lan.ra='relay'
    uci set dhcp.lan.dhcpv6='relay'
    uci set dhcp.lan.ndp='relay'
    uci set dhcp.lan.force='1'
    uci del_list firewall.@zone[1].network="wan"
    uci del_list firewall.@zone[1].network="wan6"
    uci add_list firewall.@zone[1].network="\${DSLITE_NAME}"
    uci add_list firewall.@zone[1].network="\${DSLITE6_NAME}"
    uci set firewall.@zone[1].masq='1'
    uci set firewall.@zone[1].mtu_fix='1'
}
[ -n "\${mape_br}" ] && [ -n "\${mape_ealen}" ] && {
    uci set network.wan.disabled='1'
    uci set network.wan.auto='0'
    uci set network.wan6.disabled='1'
    uci set network.wan6.auto='0'
    uci set network.\${MAP6_NAME}=interface
    uci set network.\${MAP6_NAME}.proto='dhcpv6'
    uci set network.\${MAP6_NAME}.device="\${WAN_DEF}"
    uci set network.\${MAP6_NAME}.reqaddress='try'
    uci set network.\${MAP6_NAME}.reqprefix='auto'
    [ -n "\${mape_gua_mode}" ] && uci set network.\${MAP6_NAME}.ip6prefix="\${mape_gua_prefix}"
    uci set network.\${MAP_NAME}=interface
    uci set network.\${MAP_NAME}.proto='map'
    uci set network.\${MAP_NAME}.maptype='map-e'
    uci set network.\${MAP_NAME}.peeraddr="\${mape_br}"
    uci set network.\${MAP_NAME}.ipaddr="\${mape_ipv4_prefix}"
    uci set network.\${MAP_NAME}.ip4prefixlen="\${mape_ipv4_prefixlen}"
    uci set network.\${MAP_NAME}.ip6prefix="\${mape_ipv6_prefix}"
    uci set network.\${MAP_NAME}.ip6prefixlen="\${mape_ipv6_prefixlen}"
    uci set network.\${MAP_NAME}.ealen="\${mape_ealen}"
    uci set network.\${MAP_NAME}.psidlen="\${mape_psidlen}"
    uci set network.\${MAP_NAME}.offset="\${mape_psid_offset}"
    uci set network.\${MAP_NAME}.mtu='1460'
    uci set network.\${MAP_NAME}.encaplimit='ignore'
    uci set network.\${MAP_NAME}.legacymap='1'
    uci set network.\${MAP_NAME}.tunlink="\${MAP6_NAME}"
    uci set dhcp.\${MAP6_NAME}=dhcp
    uci set dhcp.\${MAP6_NAME}.interface="\${MAP6_NAME}"
    uci set dhcp.\${MAP6_NAME}.master='1'
    uci set dhcp.\${MAP6_NAME}.ra='relay'
    uci set dhcp.\${MAP6_NAME}.dhcpv6='relay'
    uci set dhcp.\${MAP6_NAME}.ndp='relay'
    uci set dhcp.\${MAP6_NAME}.ignore='1'
    uci set dhcp.lan.ra='relay'
    uci set dhcp.lan.dhcpv6='relay'
    uci set dhcp.lan.ndp='relay'
    uci set dhcp.lan.force='1'
    uci del_list firewall.@zone[1].network="wan"
    uci del_list firewall.@zone[1].network="wan6"
    uci add_list firewall.@zone[1].network="\${MAP_NAME}"
    uci add_list firewall.@zone[1].network="\${MAP6_NAME}"
    uci set firewall.@zone[1].masq='1'
    uci set firewall.@zone[1].mtu_fix='1'
    cat > /lib/netifd/proto/map.sh << 'MAP_SH_EOF'
\${map_sh_content}
MAP_SH_EOF
}
[ -n "\${ap_ip_address}" ] && {
    uci set network.wan.disabled='1'
    uci set network.wan.auto='0'
    uci set network.wan6.disabled='1'
    uci set network.wan6.auto='0'
    uci set network.\${AP_NAME}=interface
    uci set network.\${AP_NAME}.proto='static'
    uci set network.\${AP_NAME}.device="\${LAN_DEF}"
    uci set network.\${AP_NAME}.ipaddr="\${ap_ip_address}"
    uci set network.\${AP_NAME}.netmask='255.255.255.0'
    uci set network.\${AP_NAME}.gateway="\${ap_gateway}"
    uci set network.\${AP_NAME}.dns="\${ap_gateway}"
    uci set network.\${AP_NAME}.delegate='0'
    uci set network.\${AP6_NAME}=interface
    uci set network.\${AP6_NAME}.proto='dhcpv6'
    uci set network.\${AP6_NAME}.device="@\${AP_NAME}"
    uci set network.\${AP6_NAME}.reqaddress='try'
    uci set network.\${AP6_NAME}.reqprefix='no'
    uci set network.\${AP6_NAME}.type='bridge'
    [ -n "$(uci -q get wireless.default_radio0)" ] && uci set wireless.default_radio0.network="\${AP_NAME}"
    [ -n "$(uci -q get wireless.default_radio1)" ] && uci set wireless.default_radio1.network="\${AP_NAME}"
    [ -n "$(uci -q get wireless.default_radio2)" ] && uci set wireless.default_radio2.network="\${AP_NAME}"
    [ -x /etc/init.d/odhcpd ] && /etc/init.d/odhcpd enabled && /etc/init.d/odhcpd disable
    [ -x /etc/init.d/odhcpd ] && /etc/init.d/odhcpd running && /etc/init.d/odhcpd stop
    [ -x /etc/init.d/dnsmasq ] && /etc/init.d/dnsmasq enabled && /etc/init.d/dnsmasq disable
    [ -x /etc/init.d/dnsmasq ] && /etc/init.d/dnsmasq running && /etc/init.d/dnsmasq stop
    [ -x /etc/init.d/firewall ] && /etc/init.d/firewall enabled && /etc/init.d/firewall disable
    [ -x /etc/init.d/firewall ] && /etc/init.d/firewall running && /etc/init.d/firewall stop
}
[ -n "\${enable_ttyd}" ] && {
    uci set ttyd.@ttyd[0].ipv6='1'
    uci set ttyd.@ttyd[0].command='/bin/login -f root'
}
[ -n "\${enable_irqbalance}" ] && {
    uci set irqbalance.irqbalance=irqbalance
    uci set irqbalance.irqbalance.enabled='1'
}
[ -n "\${enable_samba4}" ] && {
    NAS="openwrt"
    MNT="/mnt/sda"
    uci set samba4.@samba[0]=samba
    uci set samba4.@samba[0].workgroup='WORKGROUP'
    uci set samba4.@samba[0].charset='UTF-8'
    uci set samba4.@samba[0].description='Samba on OpenWRT'
    uci set samba4.@samba[0].enable_extra_tuning='1'
    uci set samba4.@samba[0].interface='lan'
    uci set samba4.sambashare=sambashare
    uci set samba4.sambashare.name="\${NAS}"
    uci set samba4.sambashare.path="\${MNT}"
    uci set samba4.sambashare.read_only='no'
    uci set samba4.sambashare.force_root='1'
    uci set samba4.sambashare.guest_ok='yes'
    uci set samba4.sambashare.inherit_owner='yes'
    uci set samba4.sambashare.create_mask='0777'
    uci set samba4.sambashare.dir_mask='0777'
}
# BEGIN_CUSTOM_COMMANDS
# END_CUSTOM_COMMANDS
uci commit 2>/dev/null
echo "All done!"
[ -n "\${backup_path}" ] && sysupgrade -q -k -b "\${backup_path}"
exit 0`;

// config.jsÁõ∏ÂΩì„ÅÆË®≠ÂÆö
const config = {
    show_help: true,
    image_url: "https://downloads.openwrt.org",
    info_url: "https://openwrt.org/start?q={title}&do=search",
    asu_url: "https://sysupgrade.openwrt.org",
    asu_extra_packages: ["luci"],
    min_version: "21.02.0",  // ÊúÄÂ∞è„Çµ„Éù„Éº„Éà„Éê„Éº„Ç∏„Éß„É≥
};

// „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
let app = {
    versions: [],
    devices: [],
    selectedVersion: '',
    templateLoaded: false,
    availablePackages: [], // „Éá„Éê„Ç§„ÇπÂõ∫Êúâ„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏„É™„Çπ„Éà
    archPackagesMap: {},
};

// ÂÖ¨Âºè„Å®Âêå„Åò„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
let current_device = {};
        
// map.sh„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
let mapShCache = undefined;

// ==================== MAP-EÂ∞ÇÁî®Âá¶ÁêÜ„É¢„Ç∏„É•„Éº„É´ ====================
const MapEProcessor = {
    // MAP-EË®≠ÂÆö„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
    isActive(config, apiInfo) {
        if (config.connectionMode === 'auto') {
            return !!(apiInfo?.mape?.brIpv6Address);
        } else if (config.connectionMode === 'manual') {
            return config.connectionType === 'mape';
        }
        return false;
    },
    
    // ÂøÖË¶Å„Å™map.sh„Åå„Ç≠„É£„ÉÉ„Ç∑„É•„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    isScriptCached() {
        return mapShCache !== undefined && mapShCache !== null;
    },
    
    // map.sh„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÅÆÁ¢∫‰øù
    async ensureScriptReady() {
        if (!mapShCache) {
            await loadMapSh();
            
            if (!mapShCache) {
                throw new Error('Failed to download map.sh script. Please check your internet connection and try again.');
            }
        }
    },
    
    // „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº„ÅÆÁΩÆÊèõ
    replacePlaceholder(content) {
        if (!content.includes('${map_sh_content}')) {
            return content;
        }
        
        if (!mapShCache) {
            throw new Error('MAP-E script not available in cache');
        }
        
        const result = content.replace(/\$\{map_sh_content\}/g, mapShCache);
        
        if (result.includes('${map_sh_content}')) {
            throw new Error('MAP-E script embedding failed - placeholder still exists');
        }
        
        return result;
    },
    
    // ‰∫ãÂâçÊ∫ñÂÇôÂá¶ÁêÜÔºàË®≠ÂÆöÁîªÈù¢Ë°®Á§∫ÊôÇÔºâ
    async prepareForDisplay(config, apiInfo) {
        if (this.isActive(config, apiInfo)) {
            await loadMapSh();
        }
    },
    
    // „Éì„É´„ÉâÊôÇÂá¶ÁêÜÔºà„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºÁΩÆÊèõÔºâ
    async processForBuild(script, config, apiInfo) {
        if (!this.isActive(config, apiInfo)) {
            return script;
        }
    
        if (!script.includes('${map_sh_content}')) {
            return script;
        }
    
        await this.ensureScriptReady();
        return this.replacePlaceholder(script);
    }
};

const SEARCH_URL_TEMPLATE = 'https://openwrt.org/start?do=search&q={id}';
function applySearchUrls(db) {
  db.categories.forEach(category => {
    category.packages.forEach(pkg => {
      pkg.url = SEARCH_URL_TEMPLATE.replace(
        '{id}',
        encodeURIComponent(pkg.id)
      );
    });
  });
}

// „Éë„ÉÉ„Ç±„Éº„Ç∏„Éá„Éº„Çø„Éô„Éº„Çπ
const PACKAGE_DB = {
  categories: [
    {
      id: "basic-system",
      name: "Basic System Features",
      description: "Terminal access and file transfer tools",
      packages: [
        {
          id: "luci-app-ttyd",
          name: "luci-app-ttyd",
          enableVar: "enable_ttyd",
          checked: true
        },
        {
          id: "openssh-sftp-server",
          name: "openssh-sftp-server",
          checked: true
        },
        {
          id: "luci-app-commands",
          name: "luci-app-commands"
        },
        {
          id: "luci-app-filebrowser",
          name: "luci-app-filebrowser"
        }
      ]
    },
    {
      id: "system-management",
      name: "System Management",
      description: "CPU interrupt balancing for multi-core systems",
      packages: [
        {
          id: "luci-app-irqbalance",
          name: "luci-app-irqbalance",
          enableVar: "enable_irqbalance",
        }
      ]
    },
    {
      id: "network-management",
      name: "Network Management",
      description: "QoS, bandwidth monitoring, Wi-Fi scheduling, and network utilities",
      packages: [
        {
          id: "luci-app-qos",
          name: "luci-app-qos"
        },
        {
          id: "luci-app-sqm",
          name: "luci-app-sqm",
          dependencies: ["tc-full"]
        },
        {
          id: "tc-full",
          name: "tc-full",
          hidden: true
        },
        {
          id: "luci-app-statistics",
          name: "luci-app-statistics",
          dependencies: ["collectd", "rrdtool1"]
        },
        {
          id: "collectd",
          name: "collectd",
          hidden: true
        },
        {
          id: "rrdtool1",
          name: "rrdtool1",
          hidden: true
        },
        {
          id: "nlbwmon",
          name: "nlbwmon"
        },
        {
          id: "wifischedule",
          name: "wifischedule"
        },
        {
          id: "luci-app-wol",
          name: "luci-app-wol"
        },
        {
          id: "luci-app-ddns",
          name: "luci-app-ddns"
        },
        {
          id: "mwan3",
          name: "mwan3"
        },
        {
          id: "luci-app-mwan3",
          name: "luci-app-mwan3",
          dependencies: ["mwan3"]
        }
      ]
    },
    {
      id: "security-tools",
      name: "Security Tools",
      description: "Intrusion prevention and IP blocking tools",
      packages: [
        {
          id: "znc-mod-fail2ban",
          name: "znc-mod-fail2ban"
        },
        {
          id: "banip",
          name: "banip"
        }
      ]
    },
    {
      id: "system-monitoring",
      name: "System Monitoring",
      description: "System watchdog and network monitoring",
      packages: [
        {
          id: "luci-app-watchcat",
          name: "luci-app-watchcat"
        }
      ]
    },
    {
      id: "diagnostic-tools",
      name: "Network Diagnostic Tools",
      description: "System monitoring and network analysis tools",
      packages: [
        {
          id: "htop",
          name: "htop",
          dependencies: ["collectd-htop", "collectd-mod-thermal"]
        },
        {
          id: "collectd-htop",
          name: "collectd",
          hidden: true
        },
        {
          id: "collectd-mod-thermal",
          name: "collectd-mod-thermal",
          hidden: true
        },
        {
          id: "mtr",
          name: "mtr"
        },
        {
          id: "nmap",
          name: "nmap"
        },
        {
          id: "tcpdump",
          name: "tcpdump"
        }
      ]
    },
    {
      id: "themes-dashboard",
      name: "Themes and Dashboard",
      description: "UI themes and dashboard improvements",
      packages: [
        {
          id: "luci-mod-dashboard",
          name: "luci-mod-dashboard"
        },
        {
          id: "luci-theme-openwrt",
          name: "luci-theme-openwrt",
          dependencies: ["luci-theme-material", "luci-theme-openwrt-2020"]
        },
        {
          id: "luci-theme-material",
          name: "luci-theme-material"
        },
        {
          id: "luci-theme-openwrt-2020",
          name: "luci-theme-openwrt-2020"
        }
      ]
    },
    {
      id: "utilities",
      name: "Utilities",
      description: "System upgrade tools and VPN utilities",
      packages: [
        {
          id: "attendedsysupgrade-common",
          name: "attendedsysupgrade-common"
        },
        {
          id: "wireguard-tools",
          name: "wireguard-tools"
        },
        {
          id: "luci-app-wireguard",
          name: "luci-app-wireguard",
          dependencies: ["wireguard-tools"]
        },
        {
          id: "luci-app-dockerman",
          name: "luci-app-dockerman",
          dependencies: ["docker-compose"]
        },
        {
          id: "docker-compose",
          name: "docker-compose",
          dependencies: ["docker"],
          hidden: true
        },
        {
          id: "docker",
          name: "docker",
          hidden: true
        },
        {
          id: "luci-app-openvpn",
          name: "luci-app-openvpn"
        },
        {
          id: "luci-app-minidlna",
          name: "luci-app-minidlna"
        }
      ]
    },
    {
      id: "usb-storage",
      name: "USB Storage Support",
      description: "USB storage kernel module and filesystem tools",
      packages: [
        {
          id: "kmod-usb-storage",
          name: "kmod-usb-storage",
          dependencies: [
            "block-mount",
            "kmod-usb-storage-uas",
            "usbutils",
            "libblkid1",
            "gdisk"
          ]
        },
        {
          id: "block-mount",
          name: "block-mount",
          hidden: true
        },
        {
          id: "kmod-usb-storage-uas",
          name: "kmod-usb-storage-uas",
          hidden: true
        },
        {
          id: "usbutils",
          name: "usbutils",
          hidden: true
        },
        {
          id: "libblkid1",
          name: "libblkid1",
          hidden: true
        },
        {
          id: "gdisk",
          name: "gdisk",
          hidden: true
        },
        {
          id: "dosfstools",
          name: "dosfstools",
          dependencies: ["kmod-fs-vfat"]
        },
        {
          id: "kmod-fs-vfat",
          name: "kmod-fs-vfat",
          hidden: true
        },
        {
          id: "e2fsprogs",
          name: "e2fsprogs",
          dependencies: ["kmod-fs-ext4"]
        },
        {
          id: "kmod-fs-ext4",
          name: "kmod-fs-ext4",
          hidden: true
        },
        {
          id: "f2fs-tools",
          name: "f2fs-tools",
          dependencies: ["kmod-fs-f2fs"]
        },
        {
          id: "kmod-fs-f2fs",
          name: "kmod-fs-f2fs",
          hidden: true
        },
        {
          id: "exfat-fsck",
          name: "exfat-fsck",
          dependencies: ["kmod-fs-exfat"]
        },
        {
          id: "kmod-fs-exfat",
          name: "kmod-fs-exfat",
          hidden: true
        },
        {
          id: "ntfs-3g",
          name: "ntfs-3g",
          dependencies: ["kmod-fs-ntfs3"]
        },
        {
          id: "kmod-fs-ntfs3",
          name: "kmod-fs-ntfs3",
          hidden: true
        },
        {
          id: "hfsfsck",
          name: "hfsfsck",
          dependencies: ["kmod-fs-hfs", "kmod-fs-hfsplus"]
        },
        {
          id: "kmod-fs-hfs",
          name: "kmod-fs-hfs",
          hidden: true
        },
        {
          id: "kmod-fs-hfsplus",
          name: "kmod-fs-hfsplus",
          hidden: true
        },
        {
          id: "hdparm",
          name: "hdparm",
          dependencies: ["hd-idle"]
        },
        {
          id: "hd-idle",
          name: "hd-idle",
          hidden: true
        },
        {
          id: "kmod-usb-ledtrig-usbport",
          name: "kmod-usb-ledtrig-usbport"
        }
      ]
    },
    {
      id: "file-sharing",
      name: "File Sharing",
      description: "SMB/CIFS file sharing server",
      packages: [
        {
          id: "luci-app-samba4",
          name: "luci-app-samba4",
          dependencies: ["wsdd2"],
          enableVar: "enable_samba4"
        },
        {
          id: "wsdd2",
          name: "wsdd2",
          hidden: true
        }
      ]
    }
  ]
};

applySearchUrls(PACKAGE_DB);

// Java Script -------------------------------------------------------------------
// JS ----------------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', init);

// ==================== „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Áµ±‰∏Ä ====================
// ==================== Áµ±Âêà„ÉªÁ∑èÂêà „Éá„Éê„ÉÉ„Ç´„Éº ====================
const ErrorHandler = {
    // „Ç®„É©„Éº„Çø„Ç§„ÉóÂàÜÈ°û
    classify(error, response = null) {
        // HTTP„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ„Éô„Éº„Çπ„ÅÆÂàÜÈ°û
        if (response?.status === 404) return 'VERSION_NOT_AVAILABLE';
        if (response?.status === 403) return 'PERMISSION_DENIED';
        
        if (response?.status === 404) return 'NOT_FOUND';
        // CORS „Ç®„É©„Éº„ÅØÁúü„ÅÆ„Ç®„É©„Éº„Å®„Åó„Å¶Êâ±„ÅÜ
        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            return 'NETWORK_ERROR';
        }
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) return 'NETWORK_ERROR';
        if (error.message?.includes('timeout')) return 'TIMEOUT';
        return 'UNKNOWN';
    },

    // Áµ±‰∏Ä„Ç®„É©„ÉºÂá¶ÁêÜ
    handle(context, error, response = null) {
        const errorType = this.classify(error, response);
        
        // ÊúüÂæÖ„Åï„Çå„ÇãÂãï‰Ωú„ÅÆÂ†¥Âêà„ÅØÈÄöÂ∏∏„É≠„Ç∞
        const expectedBehaviors = ['VERSION_NOT_AVAILABLE', 'EXPECTED_CORS_REJECTION', 'PERMISSION_DENIED'];
        const isExpected = expectedBehaviors.includes(errorType);
        
        // „É≠„Ç∞Âá∫ÂäõÔºàÊúüÂæÖ„Åï„Çå„ÇãÂãï‰Ωú„ÅØÈÄöÂ∏∏„É≠„Ç∞„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØ„Ç®„É©„Éº„É≠„Ç∞Ôºâ
        if (isExpected) {
            console.log(`[${context}] ${errorType}: Expected behavior for older versions`, {
                message: error.message,
                response: response ? {
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url
                } : null
            });
        } else {
            console.error(`[${context}] ${errorType}: Unexpected error`, {
                message: error.message,
                stack: error.stack,
                response: response ? {
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url
                } : null
            });
        }
        
        // „Ç®„É©„Éº„Çø„Ç§„ÉóÂà•Âá¶ÁêÜ
        switch (errorType) {
            case 'VERSION_NOT_AVAILABLE': {
                console.log(`‚úì Version ${app.selectedVersion} not available - This is expected for older versions`);
                hideDeviceInfo();

                // „Éë„ÉÉ„Ç±„Éº„Ç∏„Çª„ÇØ„Çø„Éº„ÇíÂé≥Ê†º„Å´Èñâ„Åò„ÇãÔºèÂàùÊúüÂåñ
                app.devicePackages = [];
                // package-categories „ÇíÁ©∫„Å´„Åó„Å¶„Éë„Éç„É´„Åî„Å®Èö†„Åô
                const pkgPanel = document.getElementById('packages');
                const categories = document.getElementById('package-categories');
                if (categories) categories.innerHTML = '';
                if (pkgPanel) pkgPanel.style.display = 'none';

                break;
            }
            case 'PERMISSION_DENIED':
            case 'EXPECTED_CORS_REJECTION':
                console.log(`‚úì Access blocked by CORS policy - This is expected for older versions`);
                hideDeviceInfo();
                break;
            case 'NETWORK_ERROR':
                console.warn(`Network connectivity issue in ${context}`);
                hideDeviceInfo();
                break;
            default:
                console.error(`Unexpected error in ${context}:`, error.message);
                hideDeviceInfo();
        }
        return { success: false, errorType, context, isExpected };
    },

    // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ÔºàÊã°ÂºµÁâàÔºâ
    debug(context, message, data = null) {
        console.log(`[DEBUG] ${context}: ${message}`);
        if (data) {
            console.log('Data:', data);
        }
        
        // ‚òÖËøΩÂä†Ôºö„Éë„ÉÉ„Ç±„Éº„Ç∏Èñ¢ÈÄ£„Å™„ÇâËá™Âãï„Åß„Éë„ÉÉ„Ç±„Éº„Ç∏Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ
        if (context.includes('Package') || context.includes('package')) {
            this.packageDebug.checkMissing();
        }
    },

    // Èñ¢Êï∞Âëº„Å≥Âá∫„ÅóËøΩË∑°
    trace(functionName, ...args) {
        console.log(`[TRACE] ${functionName}() called`);
        console.log('Arguments:', args);
        console.trace(`${functionName} call stack:`);
    },

    packageDebug: {
        // ÂèñÂæó„É≠„Ç∞Ë®òÈå≤
        logFetch(url, success, packages = []) {
            const source = url.split('/').slice(-2).join('/');
            
            if (success) {
                const kmods = packages.filter(p => 
                    (typeof p === 'string' ? p : p?.name)?.startsWith('kmod-')
                );
                
                console.log(`[PKG Fetch] OK ${source}: ${packages.length} pkgs (${kmods.length} kmods)`);
                
            } else {
                console.log(`[PKG Fetch] NG ${source}: FAILED`);
            }
        },
        
        // Ê¨†ËêΩ„Éë„ÉÉ„Ç±„Éº„Ç∏„ÉÅ„Çß„ÉÉ„ÇØ
        checkMissing() {
            if (!PACKAGE_DB || !app.devicePackages) return;
            
            const missing = [];
            const notDisplayed = [];
            
            // PACKAGE_DB„ÅÆÂÖ®„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            PACKAGE_DB.categories.forEach(category => {
                category.packages.forEach(pkg => {
                    const inDevice = app.devicePackages?.some(p => 
                        (typeof p === 'string' ? p : p?.name) === pkg.name
                    );
                    const inUI = document.querySelector(`[data-package="${pkg.name}"]`);
                    
                    if (!inDevice) missing.push(pkg.name);
                    if (inDevice && !inUI) notDisplayed.push(pkg.name);
                });
            });
            
            if (missing.length > 0) {
                console.warn('[NG] Missing from device packages:', missing);
            }
            if (notDisplayed.length > 0) {
                console.warn('[NG] In device but not displayed:', notDisplayed);
            }
            if (missing.length === 0 && notDisplayed.length === 0) {
                console.log('[OK] All packages available');
            }
        },
        
        // ÂÖ®ÊÉÖÂ†±„ÉÄ„É≥„Éó
        dumpAll() {
            console.group('[Package Debug] Complete Dump');
            console.log('Device packages:', app.devicePackages?.length || 0);
            console.log('First 10 packages:', app.devicePackages?.slice(0, 10));
            const kmods = app.devicePackages?.filter(p => 
                (typeof p === 'string' ? p : p?.name)?.startsWith('kmod-')
            );
            console.log('Total kmods:', kmods?.length || 0);
            console.log('First 10 kmods:', kmods?.slice(0, 10).map(k => 
                typeof k === 'string' ? k : k?.name
            ));
            console.groupEnd();
        }
    }
};
        
// ==================== URLÁÆ°ÁêÜ„ÅÆÁµ±‰∏ÄÈñ¢Êï∞ ====================
function setupVersionUrls(version) {
    if (!config.image_urls) config.image_urls = {};
    if (!config.overview_urls) config.overview_urls = {};

    if (config.image_urls[version]) return;

    const overview_url = config.image_url;
    const image_url = (typeof upstream_config !== 'undefined' && upstream_config.image_url_override)
        ? upstream_config.image_url_override
        : config.image_url;

    const isSnapshot = /SNAPSHOT$/i.test(version);
    const basePath   = isSnapshot ? 'snapshots' : `releases/${encodeURIComponent(version)}`;

    config.overview_urls[version] = `${overview_url}/${basePath}/`;
    config.image_urls[version]    = `${image_url}/${basePath}/`;
}  

// ==================== ÂàùÊúüÂåñÈñ¢Êï∞ ====================
async function init() {
    try {
        // „Éê„Éº„Ç∏„Éß„É≥Ë™≠„ÅøËæº„Åø
        await loadVersions();

        // „Ç§„Éô„É≥„Éà„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞ÔºàË¶ÅÁ¥†Â≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
        if (typeof bindEvents === 'function') {
            try {
                bindEvents();
            } catch (error) {
                console.error('Failed to bind events:', error);
            }
        }

        // ÂàùÊúüÂåñÊÆµÈöé„Åß„ÅØÁîüÊàê„Åó„Å™„ÅÑÔºà„Éá„Éê„Ç§„ÇπÈÅ∏ÊäûÔºã„Éë„ÉÉ„Ç±„Éº„Ç∏ÂèñÂæóÂÆå‰∫ÜÂæå„Å´ÁîüÊàê

        // „ÉÜ„É≥„Éó„É¨„Éº„Éà„Å®„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆÊõ¥Êñ∞
        try {
            if (typeof refreshTemplateAndPackages === 'function') {
                await refreshTemplateAndPackages();
            }
        } catch (error) {
            console.error('Failed to refresh template and packages:', error);
        }

        // ====== „Åì„Åì„ÅßÂøÖÈ†àDOM„Å®‰æùÂ≠òÁä∂ÊÖã„ÅåÊèÉ„ÅÜ„Åæ„ÅßÂæÖÊ©ü ======
        await waitForReady([
            'versions',
            'models',
            //'use-package-selector-details'
            // ÂøÖË¶Å„Å™„Çâ‰ªñ„ÅÆË¶ÅÁ¥†„ÇÇËøΩÂä†
        ]);

        // „Éë„ÉÉ„Ç±„Éº„Ç∏DB„Çí„É≠„Éº„ÉâÔºÜUIÂèçÊò†
        try {
            // await loadPackageDatabase();
            // updateInstalledPackageList();
        } catch (error) {
            console.error('Failed to load/update package DB:', error);
        }

        // ISPÊÉÖÂ†±ÂèñÂæó„ÅØ details Â±ïÈñãÊôÇ„Å´ÁßªÂãïÔºàauto „Éà„É™„Ç¨„ÉºÔºâ
        console.log('Initialization completed. ISP info will be fetched when details are opened.');
        
        // ÂàùÊúüÂåñÂÆå‰∫ÜÂæå„ÄÅ„Çª„É¨„ÇØ„Çø„Éº„ÅÆÂàùÊúüÂÄ§„ÇíÁ¢∫ÂÆü„Å´ÂèçÊò†Ôºà„Éê„Ç∞‰øÆÊ≠£Ôºâ
        setTimeout(() => {
            refreshTemplateAndPackages();
        }, 100);

    } catch (error) {
        console.error('Failed to initialize:', error);
        updateIspDisplay(
            'Initialization error',
            'Failed to initialize application: ' + error.message
        );
    }
}

// ==================== ÂøÖÈ†àË¶ÅÁ¥†„ÅÆÂ≠òÂú®„ÇíÂæÖ„Å§„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ ====================
function waitForReady(ids = []) {
    return new Promise(resolve => {
        const check = () => {
            if (ids.every(id => document.getElementById(id))) {
                resolve();
            } else {
                requestAnimationFrame(check);
            }
        };
        check();
    });
}

// ==================== ÂÖ¨Âºè‰∫íÊèõ„Éá„Éê„Ç§„ÇπÁÆ°ÁêÜÈñ¢Êï∞ ====================
// ÂÖ¨Âºè„Å®Âêå„ÅòÈñ¢Êï∞Âêç„Éª„É≠„Ç∏„ÉÉ„ÇØ„Åß„Éá„Éê„Ç§„ÇπË®≠ÂÆö
function setModel(target, id) {
    if (target && id) {
        const title = document.getElementById('models').value;
        for (const device of app.devices) {
            if ((device.target === target && device.id === id) || getDeviceTitle(device) === title) {
                document.getElementById('models').value = getDeviceTitle(device);
                selectDevice(device);
                return;
            }
        }
    }
}

// ==================== „Éë„ÉÉ„Ç±„Éº„Ç∏Èñ¢Êï∞ ====================
function normalizeLang(lang) {
  const map = {
    en: '',       // Ëã±Ë™û„ÅØ i18n „Éë„ÉÉ„Ç±„Éº„Ç∏‰∏çË¶Å
    pt_br: 'pt-br',
    zh_cn: 'zh-cn',
    zh_tw: 'zh-tw'
  };
  return (map[lang] ?? String(lang || '').toLowerCase());
}

function asuI18nDB(lang) {
    const norm = normalizeLang(lang);
    const isEN = !norm;
    const s = isEN ? '' : `-${norm}`;
    const make = (key) => (isEN ? [] : [`luci-i18n-${key}${s}`]);
    
    const result = {
        base: make('base'),
        opkg: make('opkg'),
        firewall: make('firewall')
    };
    
    // PACKAGE_DB„Åã„ÇâÂãïÁöÑ„Å´ÁîüÊàê
    PACKAGE_DB.categories.forEach(category => {
        category.packages.forEach(pkg => {
            if (pkg.enableVar) {
                // enableVar„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„Çí‰ΩøÁî®
                const key = pkg.enableVar.replace('enable_', '');
                result[key] = make(key);
            } else if (pkg.id.startsWith('luci-app-')) {
                // luci-app-xxx„ÅÆÂ†¥Âêà„ÅØxxx„ÇíÊäΩÂá∫
                const key = pkg.id.replace('luci-app-', '');
                result[key] = make(key);
            }
            // ‰ªñ„Å´„ÇÇ„É´„Éº„É´„Åå„ÅÇ„Çå„Å∞ËøΩÂä†
        });
    });
    
    return result;
}

// ==================== i18n„Éë„ÉÉ„Ç±„Éº„Ç∏Èñ¢Êï∞ ====================
 function asuCollectPackages() {
  const lang = document.getElementById('aios-language').value?.trim() || 'en';
  const norm = normalizeLang(lang);
  const db = asuI18nDB(lang);
  const textarea = document.getElementById('asu-packages');
  let current = split(textarea.value);

  // 1) i18n „ÅÆÊï¥ÁêÜ: Ëã±Ë™û„Å™„ÇâÂÖ® i18n „ÇíÂâäÈô§„ÄÅÈùûËã±Ë™û„Å™„ÇâÁèæÂú®Ë®ÄË™û‰ª•Â§ñ„ÇíÂâäÈô§
  current = current.filter(pkg => {
    if (!pkg.startsWith('luci-i18n-')) return true;
    const m = pkg.match(/^luci-i18n-(.+?)-([A-Za-z]{2}(?:-[A-Za-z]{2})?)$/);
    const suffix = (m && m[2]) ? m[2].toLowerCase() : '';
    if (!norm) return false; // Ëã±Ë™û: i18n ÂÖ®ÊéíÈô§
    return suffix === norm;  // ÁèæÂú®Ë®ÄË™û„ÅÆ„ÅøÊ∏©Â≠ò
  });

  // 2) „Éô„Éº„Çπ„Éë„ÉÉ„Ç±„Éº„Ç∏ÈõÜÂêàÔºà„Çª„É¨„ÇØ„Çø„ÉºÈÅ∏ÊäûÔºãÊâãÂãïÂÖ•Âäõ„ÅÆÂèåÊñπÔºâ
  const baseSet = new Set();

  // „Çª„É¨„ÇØ„Çø„ÉºÈÅ∏Êäû„Åã„Çâ
  document.querySelectorAll('.package-selector-checkbox:checked').forEach(cb => {
    const names = cb.getAttribute('data-package')?.split(/\s+/) || [];
    names.forEach(n => baseSet.add(n));
  });

  // ÊâãÂãïÂÖ•Âäõ„Åã„ÇâÔºàluci-app- „Å†„Åë„Åß„Å™„ÅèÁ¥†„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏Âêç„ÇÇ„Éô„Éº„Çπ„Å®„Åó„Å¶Êâ±„ÅÜÔºâ
  current.forEach(pkg => {
    // Èô§Â§ñ: i18n Ëá™‰Ωì„ÅØ„Éô„Éº„Çπ„Åß„ÅØ„Å™„ÅÑ
    if (pkg.startsWith('luci-i18n-')) return;
    baseSet.add(pkg);
  });

  // 3) ÁèæÂú®Ë®ÄË™û„ÅÆ i18n „Åß„ÇÇ„ÄÅÂØæÂøú„Åô„Çã„Éô„Éº„Çπ„Éë„ÉÉ„Ç±„Éº„Ç∏„Åå„Å™„Åë„Çå„Å∞Èô§ÂéªÔºà„Ç¥„Éº„Çπ„ÉàÈô§ÂéªÔºâ
  current = current.filter(pkg => {
    if (!pkg.startsWith('luci-i18n-')) return true;
    const m = pkg.match(/^luci-i18n-(.+?)-([A-Za-z]{2}(?:-[A-Za-z]{2})?)$/);
    if (!m) return false;
    const key = m[1]; // luci-i18n-<key>-<lang>
    // luci-app-<key> „Åå„Éô„Éº„Çπ„Å´„Å™„Çã„Ç±„Éº„Çπ„Å´ÂØæÂøú
    return baseSet.has(`luci-app-${key}`) || baseSet.has(key);
  });

  // 4) ËøΩÂä†Èñ¢Êï∞
  const add = (pkg) => {
    if (pkg && !current.includes(pkg)) current.push(pkg);
  };

  // 5) ÈùûËã±Ë™û„ÅÆ„Åø„ÄÅÂü∫Êú¨ i18n „ÇíËøΩÂä†
  if (norm) { // Ëã±Ë™û‰ª•Â§ñ„ÅÆÂ†¥Âêà„ÅÆ„Åø
    ['base', 'opkg', 'firewall'].forEach(k => (db[k] || []).forEach(add));
  }

  // 6) ÂÖ®„Å¶„ÅÆluci-app-xxx„Éë„ÉÉ„Ç±„Éº„Ç∏„Åã„ÇâÂãïÁöÑ„Å´i18n„Éë„ÉÉ„Ç±„Éº„Ç∏„ÇíÁîüÊàê
  if (norm) { // Ëã±Ë™û‰ª•Â§ñ„ÅÆÂ†¥Âêà„ÅÆ„Åø
    baseSet.forEach(pkg => {
      // luci-app-xxxÂΩ¢Âºè„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏„ÇíÊ§úÂá∫
      const m = pkg.match(/^luci-app-(.+)$/);
      if (m) {
        const key = m[1];
        const i18nPkg = `luci-i18n-${key}-${norm}`;
        
        // „Éá„Éê„Ç§„Çπ„Éë„ÉÉ„Ç±„Éº„Ç∏„É™„Çπ„Éà„Å´Â≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™çÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
        // Â≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂÖ•„Çå„ÇãÂ†¥Âêà„ÅØ„Åì„Åì„Åßapp.devicePackages„ÇíÂèÇÁÖß
        // const exists = app.devicePackages && app.devicePackages.some(p => 
        //   (typeof p === 'string' ? p : p.name) === i18nPkg
        // );
        // if (exists) add(i18nPkg);
        
        // „Åæ„Åü„ÅØÂ≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ„Å™„Åó„ÅßËøΩÂä†ÔºàOpenWrt„ÅåËá™ÂãïÁöÑ„Å´ÁÑ°Ë¶ñ„Åô„ÇãÔºâ
        add(i18nPkg);
      }
    });
  }

  // 8) ÊúÄÁµÇÈáçË§áÊéíÈô§
  current = Array.from(new Set(current));

  textarea.value = current.join(' ');
}
        
// ==================== map.shÈñ¢ÈÄ£ ====================
// „Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„Å´ËøΩÂä†
const downloadPromises = {};

async function loadMapSh() {
    console.log('[MAP-E Download] Starting download');
    
    if (mapShCache !== undefined) {
        console.log('[MAP-E Download] Already cached');
        return;
    }
    
    try {
        const scriptUrl = 'https://site-u.pages.dev/build/scripts/map.sh.new';
        console.log('[MAP-E Download] URL:', scriptUrl);
        
        const response = await fetch(scriptUrl);
        if (response.ok) {
            const content = await response.text();
            if (content && content.trim().length > 0) {
                mapShCache = content;
                console.log('[MAP-E Download] ‚úì Saved to cache, length:', content.length);
            } else {
                console.error('[MAP-E Download] ‚úó Empty response');
                mapShCache = '';
            }
        } else {
            console.error('[MAP-E Download] ‚úó HTTP', response.status);
            mapShCache = '';
        }
    } catch (error) {
        console.error('[MAP-E Download] ‚úó Failed:', error);
        mapShCache = '';
    }
}
        
// ==================== „Ç§„Éô„É≥„Éà„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞Áµ±ÂêàÈñ¢Êï∞ÔºàbindEvents„ÅÆÂ§ñ„ÅßÂÆöÁæ©Ôºâ ====================
function bindFieldEvents(fieldIds, events = ['input'], callback = null) {
    let debounceTimer;
    const debouncedHandler = (...args) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            const handler = callback || (() => syncTemplateAndPackages({ trigger: 'script' }));
            handler(...args);
        }, 300); // 300ms „Éá„Éê„Ç¶„É≥„Çπ
    };
    
    fieldIds.forEach(fieldId => {
        const el = document.getElementById(fieldId);
        if (el) {
            const eventList = Array.isArray(events) ? events : [events];
            eventList.forEach(eventType => {
                el.addEventListener(eventType, debouncedHandler);
            });
        }
    });
}

// ==================== „Ç§„Éô„É≥„Éà„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞ ====================
let eventsbound = false;  // ÈáçË§áÂÆüË°åÈò≤Ê≠¢„Éï„É©„Ç∞
function bindEvents() {
    console.log('[BIND] bindEvents called, eventsbound =', eventsbound);
    
    if (eventsbound) {
        console.log('[BIND] Events already bound, skipping');
        return;
    }
    
    console.log('[BIND] Setting eventsbound = true');
    eventsbound = true;  // „Éï„É©„Ç∞„Çª„ÉÉ„Éà
    
    const versionsEl = document.getElementById('versions');
    if (versionsEl) versionsEl.addEventListener('change', handleVersionChange);
    
    const modelsEl = document.getElementById('models');
    if (modelsEl) modelsEl.addEventListener('input', handleDeviceSearch);

    const aiosConfigDetails = document.getElementById('use-aios-config-details');
    if (aiosConfigDetails) aiosConfigDetails.addEventListener('toggle', toggleAiosConfig);
    
    const pkgSelectorDetails = document.getElementById('use-package-selector-details');
    if (pkgSelectorDetails) pkgSelectorDetails.addEventListener('toggle', togglePackageSelector);
    
    const buildBtnEl = document.getElementById('request-build');
    if (buildBtnEl) {
        console.log('[BIND] Adding click listener to build button');
        
        buildBtnEl.removeAttribute('href');
        buildBtnEl.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            
            console.log('[BIND] About to call buildAsuRequest');
            buildAsuRequest();
            console.log('[BIND] buildAsuRequest call completed');
        });
    }

// ===== Âü∫Êú¨Ë®≠ÂÆö„Éï„Ç£„Éº„É´„Éâ„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†ÂèçÊò† =====
    const basicFields = [
        'aios-language',
        'aios-country', 
        'aios-timezone',
        'aios-zonename',
        'aios-lan-ipv4',
        'aios-lan-ipv6',
        'aios-device-name',
        'aios-root-password',
        'aios-wifi-ssid',
        'aios-wifi-password',
        'aios-ssh-interface',
        'aios-ssh-port',
        'aios-flow-offloading',
        'aios-backup-path'
    ];

    // ===== „Éï„Ç£„Éº„É´„Éâ„Ç§„Éô„É≥„Éà„ÅÆÁµ±Âêà„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞ =====
    const fieldGroups = {
        basic: basicFields,  // ‰∏ä„ÅßÂÆöÁæ©„Åó„ÅübasicFields„Çí‰ΩøÁî®
        pppoe: ['pppoe-username', 'pppoe-password'],
        dslite: ['dslite-aftr-address', 'dslite-aftr-type', 'dslite-area'],
        mape: [
            'mape-br', 'mape-ealen', 'mape-ipv4-prefix', 'mape-ipv4-prefixlen',
            'mape-ipv6-prefix', 'mape-ipv6-prefixlen', 'mape-psid-offset',
            'mape-psidlen', 'mape-gua-prefix'
        ],
        ap: ['ap-ip-address', 'ap-gateway']
    };

    // ‰∏ÄÊã¨„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞
    bindFieldEvents(fieldGroups.basic);
    bindFieldEvents(fieldGroups.pppoe);
    bindFieldEvents(fieldGroups.dslite, ['input', 'change']);  // DS-Lite„ÅØ2„Å§„ÅÆ„Ç§„Éô„É≥„Éà
    bindFieldEvents(fieldGroups.mape);
    bindFieldEvents(fieldGroups.ap);

    // ===== „É©„Ç∏„Ç™„Éú„Çø„É≥„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†ÂèçÊò† =====
    // DS-Lite mode
    document.querySelectorAll('input[name="dsliteMode"]').forEach(radio => {
        radio.addEventListener('change', handleDsliteModeChange);
    });
    
    // Connection mode
    document.querySelectorAll('input[name="connectionMode"]').forEach(radio => {
        radio.addEventListener('change', handleConnectionModeChange);
    });
    
    // Connection type
    document.querySelectorAll('input[name="connectionType"]').forEach(radio => {
        radio.addEventListener('change', handleConnectionTypeChange);
    });
    
    // MAP-E type
    document.querySelectorAll('input[name="mapeType"]').forEach(radio => {
        radio.addEventListener('change', handleMapeTypeChange);
    });
    
    // ===== „Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„ÉàÈñ¢ÈÄ£ =====
    document.addEventListener('click', function (e) {
        if (!e.target.closest('.autocomplete')) {
            hideAutocomplete();
        }
    });
    
    // „Éá„Éï„Ç©„É´„Éà„ÅØAuto„É¢„Éº„Éâ
    const manualSection = document.getElementById('manual-connection-section');
    if (manualSection) manualSection.style.display = 'none';

    const ispDetectionGroup = document.getElementById('isp-detection-group');
    if (ispDetectionGroup) ispDetectionGroup.style.display = 'block'; // AutoÊôÇ„ÅØË°®Á§∫

    // ÂÖ®„Å¶„ÅÆÊé•Á∂ö„Çø„Ç§„ÉóÂõ∫Êúâ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÈùûË°®Á§∫
    const connectionSections = [
        'pppoe-section',
        'dslite-section', 
        'mape-manual-section',
        'ap-section'
    ];

    connectionSections.forEach(id => {
        const section = document.getElementById(id);
        if (section) section.style.display = 'none';
    });
}

// ==================== „Éë„ÉÉ„Ç±„Éº„Ç∏„Çª„É¨„ÇØ„Çø„ÉºÈñ¢ÈÄ£ ====================
function togglePackageSelector(e) {
   const configSection = document.getElementById('package-selector-config');
   configSection.style.display = e.target.open ? 'block' : 'none';
}

function generatePackageSelector() {
   const container = document.getElementById('package-categories');
   if (!container) return;

   container.innerHTML = '';

   // Âà©Áî®ÂèØËÉΩ„Éë„ÉÉ„Ç±„Éº„Ç∏Âêç„ÅÆ„Çª„ÉÉ„Éà„Çí‰ΩúÊàêÔºà„Éá„Éê„Ç§„ÇπÔºãOS„Éê„Éº„Ç∏„Éß„É≥„ÅßÂèñÂæóÊ∏à„Åø„ÅÆ„ÇÇ„ÅÆÔºâ
   const availablePackages = new Set();
   if (Array.isArray(app.devicePackages) && app.devicePackages.length > 0) {
       app.devicePackages.forEach(pkg => {
           const name = (typeof pkg === 'string') ? pkg : pkg && pkg.name;
           if (name) availablePackages.add(name);
       });
   }

   // Âà§ÂÆöÁõ¥Ââç„ÅÆÁä∂ÊÖã„ÇíÁ∑èÂêà„Éá„Éê„ÉÉ„Ç¨„ÅßÂá∫Âäõ
   ErrorHandler.debug(
       'generatePackageSelector',
       'State immediately before zero check',
       {
           devicePackages_raw: app.devicePackages,
           availablePackages_list: Array.from(availablePackages),
           availablePackages_size: availablePackages.size
       }
   );

   // ÂèñÂæó„Åß„Åç„Å¶„ÅÑ„Å™„ÅÑÔºàÔºùÂà§ÂÆö‰∏çËÉΩÔºâÂ†¥Âêà„ÅÆÂá¶ÁêÜ
   if (availablePackages.size === 0) {
       container.innerHTML =
           '<p class="text-muted small">Unable to retrieve the package index for this OS version/device. ' +
           'Please try a different version or device, or try again later.</p>';
       return;
   }

   // ‰æùÂ≠ò„Éë„ÉÉ„Ç±„Éº„Ç∏ID„ÅÆÈõÜÂêà„ÇíÊßãÁØâ
   const depIds = new Set();
   PACKAGE_DB.categories.forEach(cat => {
       cat.packages.forEach(pkg => {
           if (Array.isArray(pkg.dependencies)) {
               pkg.dependencies.forEach(d => depIds.add(d));
           }
       });
   });

   PACKAGE_DB.categories.forEach(category => {
       const categoryDiv = document.createElement('div');
       categoryDiv.className = 'package-category';

       const categoryTitle = document.createElement('h4');
       categoryTitle.textContent = category.name;
       categoryDiv.appendChild(categoryTitle);

       const categoryDescription = document.createElement('div');
       categoryDescription.className = 'package-category-description';
       categoryDescription.textContent = category.description;
       categoryDiv.appendChild(categoryDescription);

       const packageGrid = document.createElement('div');
       packageGrid.className = 'package-grid';

       let hasVisiblePackages = false;

       category.packages.forEach(pkg => {
           // ‰æùÂ≠ò„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØ„Éà„ÉÉ„Éó„É¨„Éô„É´ÊèèÁîª„Åó„Å™„ÅÑ
           if (depIds.has(pkg.id)) return;

           // Âé≥Ê†ºÔºöavailable „Å´„ÅÇ„Çã„ÇÇ„ÅÆ„Å†„ÅëË°®Á§∫
           const isAvailable = availablePackages.has(pkg.name);

           const packageItem = document.createElement('div');
           packageItem.className = 'package-item';
           if (pkg.hidden) packageItem.classList.add('package-hidden');

           if (!isAvailable) {
               // ÂÆåÂÖ®„Å´Èô§Â§ñ
               packageItem.style.display = 'none';
               return;
           }

           hasVisiblePackages = true;

           const formCheck = document.createElement('div');
           formCheck.className = 'form-check';

           const checkbox = document.createElement('input');
           checkbox.className = 'form-check-input package-selector-checkbox';
           checkbox.type = 'checkbox';
           checkbox.id = `pkg-${pkg.id}`;
           checkbox.setAttribute('data-package', pkg.name);
           if (pkg.dependencies) {
               checkbox.setAttribute('data-dependencies', pkg.dependencies.join(','));
           }
           if (pkg.checked) {
               checkbox.checked = true;
               checkbox.setAttribute('data-user', '1');
           }
           checkbox.addEventListener('change', handlePackageSelection);

           const label = document.createElement('label');
           label.className = 'form-check-label';
           label.setAttribute('for', `pkg-${pkg.id}`);

           const link = document.createElement('a');
           link.href = pkg.url;
           link.target = '_blank';
           link.className = 'package-link';
           link.textContent = pkg.name;

           label.appendChild(link);
           formCheck.appendChild(checkbox);
           formCheck.appendChild(label);
           packageItem.appendChild(formCheck);

           // ‰æùÂ≠ò„Éë„ÉÉ„Ç±„Éº„Ç∏„ÇÇÂé≥Ê†ºÂà§ÂÆö
           if (Array.isArray(pkg.dependencies)) {
               pkg.dependencies.forEach(depId => {
                   let depPkg;
                   for (const cat of PACKAGE_DB.categories) {
                       depPkg = cat.packages.find(p => p.id === depId);
                       if (depPkg) break;
                   }

                   const depName = depPkg ? depPkg.name : depId;
                   const depIsAvailable = availablePackages.has(depName);
                   if (!depIsAvailable) return;

                   const depItem = document.createElement('div');
                   depItem.className = 'package-dependent';

                   const depCheck = document.createElement('input');
                   depCheck.className = 'form-check-input package-selector-checkbox';
                   depCheck.type = 'checkbox';
                   depCheck.id = `pkg-${depPkg ? depPkg.id : depId}`;
                   depCheck.setAttribute('data-package', depName);
                   depCheck.addEventListener('change', handlePackageSelection);

                   const depLabel = document.createElement('label');
                   depLabel.className = 'form-check-label';
                   depLabel.setAttribute('for', `pkg-${depPkg ? depPkg.id : depId}`);

                   if (depPkg) {
                       const depLink = document.createElement('a');
                       depLink.href = depPkg.url;
                       depLink.target = '_blank';
                       depLink.className = 'package-link';
                       depLink.textContent = depPkg.name;
                       depLabel.appendChild(depLink);
                   } else {
                       depLabel.textContent = depId;
                   }

                   depItem.appendChild(depCheck);
                   depItem.appendChild(depLabel);
                   packageItem.appendChild(depItem);
               });
           }

           packageGrid.appendChild(packageItem);
       });

       if (hasVisiblePackages) {
           categoryDiv.appendChild(packageGrid);
           container.appendChild(categoryDiv);
       }
   });

   updatePackageListFromSelector();
}
        
function handlePackageSelection(e) {
    const pkg = e.target;
    const packageName = pkg.getAttribute('data-package');
    const isChecked = pkg.checked;

    // „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„ÅÆË®òÈå≤Ôºà‰ªªÊÑè‰∏äÊõ∏„ÅçOKÔºâ
    if (isChecked) {
        pkg.setAttribute('data-user', '1');
    } else {
        pkg.removeAttribute('data-user');
    }

    // ‰æùÂ≠ò„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆÂÆåÂÖ®ÂêåË™øÔºà„Ç´„É≥„Éû/Á©∫ÁôΩ„ÅÆ‰∏°ÂØæÂøúÔºâ
    const dependencies = pkg.getAttribute('data-dependencies') || '';
    const depPackages = dependencies.split(/[\s,]+/).map(s => s.trim()).filter(Boolean);

    if (depPackages.length) {
        depPackages.forEach(dep => {
            const depCheckbox = document.querySelector(`#pkg-${dep}`);
            if (!depCheckbox) return;
            depCheckbox.checked = isChecked;
            depCheckbox.disabled = false; // Âøµ„ÅÆ„Åü„ÇÅËß£Èô§
        });
    }

    updatePackageListFromSelector();
}
    
function updatePackageListFromSelector() {
    const checkedPkgs = [];
    document.querySelectorAll('.package-selector-checkbox:checked').forEach(cb => {
        const n = cb.getAttribute('data-package');
        if (n) checkedPkgs.push(n);
    });
    
    // ÂÆåÂÖ®ÂêåÊúüÔºöselectorÁî±Êù•„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØÂ∑Æ„ÅóÊõø„Åà
    const textarea = document.getElementById('asu-packages');
    const current = split(textarea.value);
    const nonSelectorPkgs = current.filter(pkg => {
        return !document.querySelector(`.package-selector-checkbox[data-package="${pkg}"]`);
    });
    const newList = [...nonSelectorPkgs, ...checkedPkgs];
    textarea.value = newList.join(' ');
    syncTemplateAndPackages({ trigger: 'selector' }); // updatedPackages‰∏çË¶Å
}

// ==================== „Éá„Éê„Ç§„Çπ„Éª„Éê„Éº„Ç∏„Éß„É≥Áµ±ÂêàÁÆ°ÁêÜ ====================
const DeviceContext = {
    // Áµ±ÂêàÊõ¥Êñ∞ÂÖ•Âè£
    async update(options = {}) {
        const {
            version = app.selectedVersion,
            deviceTitle = document.getElementById('models')?.value?.trim(),
            forceReload = false,
            trigger = 'unknown'
        } = options;
        
        console.log(`[DeviceContext] Update: ${trigger} | Version: ${version} | Device: ${deviceTitle || 'none'}`);
        
        try {
            // Phase 1: „Éê„Éº„Ç∏„Éß„É≥Êõ¥Êñ∞
            await this._updateVersion(version, forceReload);
            
            // Phase 2: „Éá„Éê„Ç§„ÇπÂá¶ÁêÜ
            await this._updateDevice(deviceTitle);
            
            // Phase 3: Áµ±ÂêàÂæåÂá¶ÁêÜ
            await this._finalizeUpdate();
            
        } catch (error) {
            ErrorHandler.handle('DeviceContext.update', error);
        }
    },
    
    async _updateVersion(version, forceReload) {
        if (version !== app.selectedVersion) {
            app.selectedVersion = version;
            console.log(`[DeviceContext] Version changed: ${version}`);
        }
    
        // MAP-EÁí∞Â¢É„Åß„ÅÆ‰∫ãÂâçÊ∫ñÂÇô
        if (window.cachedApiInfo?.mape?.brIpv6Address) {
            await loadMapSh();
        }
    
        // „Éá„Éê„Ç§„Çπ‰∏ÄË¶ßÊõ¥Êñ∞
        if (forceReload || app.devices.length === 0) {
            await loadDevices();
        }
    },
    
    // „Éá„Éê„Ç§„ÇπÊõ¥Êñ∞Âá¶ÁêÜ
    async _updateDevice(deviceTitle) {
        if (!deviceTitle || app.devices.length === 0) {
            this._clearDevice();
            return;
        }
        
        const device = app.devices.find(d => getDeviceTitle(d) === deviceTitle);
        
        if (device) {
            await this._selectDevice(device);
        } else {
            this._deviceNotFound(deviceTitle);
        }
    },
    
// „Éá„Éê„Ç§„ÇπÈÅ∏ÊäûÂá¶ÁêÜ
    async _selectDevice(device) {
        console.log(`[DeviceContext] Device selected: ${device.id}`);
        
        // „Éá„Éê„Ç§„ÇπÁä∂ÊÖãÊõ¥Êñ∞
        current_device = {
            version: app.selectedVersion,
            id: device.id,
            target: device.target
        };
        
        // „Éó„É≠„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
        try {
            const success = await loadDeviceProfile(device);
            // ÊàêÂäüÊôÇ„ÅÆ„ÅøUIË°®Á§∫
            if (success) {
                // ISP ÂÖàË™≠„ÅøÔºà„Éá„Éê„Ç§„ÇπÊ±∫ÂÆöÂæå„ÉªË°®Á§∫ÂâçÔºâ
                try {
                    await fetchApiInfoAndUpdate();
                    updateRequiredPackages();
                    asuCollectPackages();
                } catch (e) {
                    console.error('[DeviceContext] API fetch failed before showDeviceInfo:', e);
                }   
                showDeviceInfo();
            } else {
                // Â§±ÊïóÊôÇ„ÅØ„Éá„Éê„Ç§„ÇπÊÉÖÂ†±„Çí„ÇØ„É™„Ç¢
                current_device = {};
            }
        } catch (error) {
            const result = ErrorHandler.handle('DeviceContext._selectDevice', error);
            current_device = {};
            hideDeviceInfo();
            // ErrorHandler„ÅßÂá¶ÁêÜÂÆå‰∫Ü„ÄÅÂà∂Âæ°„Éï„É≠„Éº‰∏≠Êñ≠
            return;
        }
    },
    
    // Áµ±ÂêàÂæåÂá¶ÁêÜ
    async _finalizeUpdate() {
        // „Åì„Åì„Åß„ÅÆ API ÂèñÂæó„ÅØ‰∏çË¶ÅÔºà_selectDevice „ÅßÂÖàË™≠„ÅøÊ∏à„ÅøÔºâ
    },
    
    // „Éá„Éê„Ç§„ÇπÊú™Áô∫Ë¶ãÂá¶ÁêÜ
    _deviceNotFound(deviceTitle) {
        console.log(`[DeviceContext] Device not found: ${deviceTitle} (keeping name, hiding info)`);
        hideDeviceInfo();
    },
    
    // „Éá„Éê„Ç§„Çπ„ÇØ„É™„Ç¢Âá¶ÁêÜ
    _clearDevice() {
        hideDeviceInfo();
    },
    
    // „Ç®„É©„ÉºÂá¶ÁêÜ
    _handleError() {
        hideDeviceInfo();
        // current_device„ÅØ‰øùÊåÅÔºàÂæ©Êóß„ÅÆÂèØËÉΩÊÄß„ÅÆ„Åü„ÇÅÔºâ
    }
};

// ==================== Á∞°Á¥†Âåñ„Åï„Çå„ÅüÂÖ•Âè£Èñ¢Êï∞ ====================
async function handleVersionChange(e) {
    await DeviceContext.update({
        version: e.target.value,
        forceReload: true,
        trigger: 'version-change'
    });
}

function selectDevice(device) {
    document.getElementById('models').value = getDeviceTitle(device);
    hideAutocomplete();
    
    DeviceContext.update({
        deviceTitle: getDeviceTitle(device),
        trigger: 'device-selection'
    });
}

// ==================== changeModelÈñ¢Êï∞„ÅÆÁ∞°Á¥†Âåñ ====================
function changeModel(device) {
    if (device) {
        DeviceContext.update({
            deviceTitle: getDeviceTitle(device),
            trigger: 'change-model'
        });
    } else {
        DeviceContext._clearDevice();
    }
}
        
// ==================== „Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ ====================
async function loadVersions() {
    try {
        const response = await fetch('https://downloads.openwrt.org/.versions.json');
        const data = await response.json();
        // ÂÖ¨Âºè„Å®Âêå„Åò: SNAPSHOT„ÇíÊúÄÂàù„Å´ËøΩÂä†
        app.versions = ['SNAPSHOT'];
        
        // ÂÆâÂÆöÁâà„ÇíËøΩÂä†Ôºàconfig.min_version‰ª•‰∏ä„ÅÆ„ÅøÔºâ
        if (data.versions_list) {
            let versionList = data.versions_list;
            
            // min_version„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Ôºà21.02.0‰ª•Èôç„ÅÆ„ÅøÔºâ
            if (config.min_version) {
                const minParts = config.min_version.split('.').map(n => parseInt(n, 10));
                versionList = versionList.filter(version => {
                    const parts = version.split('.').map(n => parseInt(n, 10));
                    for (let i = 0; i < minParts.length; i++) {
                        if (parts[i] > minParts[i]) return true;
                        if (parts[i] < minParts[i]) return false;
                    }
                    return true;  // ÂÆåÂÖ®‰∏ÄËá¥„ÇÇÂê´„ÇÄ
                });
            }
            
            app.versions = app.versions.concat(versionList);
        }
        
        // ÂÖ®„Éê„Éº„Ç∏„Éß„É≥„ÅÆURLË®≠ÂÆö„Çí‰∫ãÂâç„Å´ÊßãÁØâ
        app.versions.forEach(ver => setupVersionUrls(ver));
        
        // „Éá„Éï„Ç©„É´„ÉàÈÅ∏Êäû: ÂÖ¨Âºè„Å®Âêå„Åò„ÅèÊúÄÊñ∞„É™„É™„Éº„ÇπÁâàÔºà2Áï™ÁõÆÔºâ
        app.selectedVersion = data.stable_version || (data.versions_list ? data.versions_list[0] : 'SNAPSHOT');
        updateVersionSelect();
        await loadDevices();
    } catch (error) {
        console.error('Failed to load versions:', error);
    }
}

function updateVersionSelect() {
    const select = document.getElementById('versions');
    select.innerHTML = '';

    app.versions.forEach(version => {
        const option = document.createElement('option');
        option.value = version;
        option.textContent = version;
        if (version === app.selectedVersion) {
            option.selected = true;
        }
        select.appendChild(option);
    });
}

// ==================== „Éá„Éê„Ç§„ÇπÁÆ°ÁêÜ ====================
async function loadDevices() {
    if (!app.selectedVersion) return;
    
    const cacheKey = `devices:${app.selectedVersion}`;
    const notFoundKey = `404:${cacheKey}`;
    
    // 404„Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
    if (profileCache[notFoundKey]) {
        console.log(`[loadDevices] Version ${app.selectedVersion} known to be unavailable`);
        app.devices = [];
        app.versionCode = null;
        app.kernelHash = null;
        hideDeviceInfo();
        return;
    }
    
    try {
        // URLË®≠ÂÆö„ÇíÁ¢∫Ë™ç
        setupVersionUrls(app.selectedVersion);
        const url = config.overview_urls[app.selectedVersion] + '.overview.json';
        
        const response = await fetch(url, {
            cache: 'no-cache',
            credentials: 'omit',
            mode: 'cors'
        });
        
        // 404„ÅØÁúü„ÅÆ„Ç®„É©„Éº„Å®„Åó„Å¶Âá¶ÁêÜ
        if (response.status === 404) {
            console.error(`Version ${app.selectedVersion} not found (HTTP 404)`);
            throw new Error('Version not available');
        }
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        app.devices = data.profiles || [];
        app.archPackagesMap = data.arch_packages || {};
        
    } catch (error) {
        if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('CORS'))) {
            console.log(`‚úì Version ${app.selectedVersion} access blocked - Normal for older versions`);
            profileCache[notFoundKey] = true;
        } else {
            console.log(`[loadDevices] Error: ${error.message}`);
        }
        app.devices = [];
        app.versionCode = null;
        app.kernelHash = null;
        hideDeviceInfo();
    }
}

function handleDeviceSearch(e) {
    const query = e.target.value.toLowerCase();

    // Á©∫ÊñáÂ≠ó„ÅÆÂ†¥Âêà„ÅØ„Éá„Éê„Ç§„ÇπÊÉÖÂ†±„Çí„ÇØ„É™„Ç¢
    if (query.length === 0) {
        hideAutocomplete();
        hideDeviceInfo();
        current_device = {};
        return;
    }

    if (query.length < 2) {
        hideAutocomplete();
        return;
    }

    const exact = [];
    const others = [];

    // ÂÖÉÈÖçÂàóÈ†Ü„ÇíÁ∂≠ÊåÅ„Åó„Å§„Å§„ÄÅÂÆåÂÖ®‰∏ÄËá¥„ÇíÂÖàÈ†≠„Å´
    for (const device of app.devices) {
        const title = getDeviceTitle(device);
        const lt = title.toLowerCase();
        const id = device.id.toLowerCase();

        if (lt === query || id === query) {
            exact.push(device);
        } else if (lt.includes(query) || id.includes(query)) {
            others.push(device);
        }
    }

    showAutocomplete(exact.concat(others));
}
        
function getDeviceTitle(device) {
    if (device.titles && device.titles.length > 0) {
        return device.titles[0].title || device.id;
    }
    return device.id;
}

function showAutocomplete(devices) {
    // Êó¢Â≠ò„ÅÆautocomplete-items„ÇíÂâäÈô§
    let existingContainer = document.querySelector('.autocomplete-items');
    if (existingContainer) {
        existingContainer.remove();
    }
    
    // Êñ∞„Åó„Åè‰ΩúÊàê
    const autocompleteDiv = document.getElementById('models-autocomplete');
    const container = document.createElement('div');
    container.className = 'autocomplete-items';
    
    if (devices.length === 0) {
        autocompleteDiv.appendChild(container);
        container.style.display = 'none';
        return;
    }

    // DocumentFragment„Çí‰ΩøÁî®„Åó„Å¶„Éê„ÉÉ„ÉÅÂá¶ÁêÜ
    const fragment = document.createDocumentFragment();
    
    devices.forEach(device => {
        const div = document.createElement('div');
        div.innerHTML = `<strong>${getDeviceTitle(device)}</strong><br><small>Target: ${device.target}</small>`;
        div.addEventListener('click', () => selectDevice(device));
        fragment.appendChild(div);
    });
    
    // ‰∏ÄÂ∫¶„Å†„ÅëDOM„Å´ËøΩÂä†
    container.appendChild(fragment);
    autocompleteDiv.appendChild(container);
    container.style.display = 'block';
}
        
function hideAutocomplete() {
    const items = document.querySelector('.autocomplete-items');
    if (items) {
        items.remove();
    }
}

// ÂàùÂõû„ÅÆ„ÅøDLÂøÖÈ†à„ÄÅÂêå‰∏Ä„Éá„Éê„Ç§„ÇπÔºãÂêå‰∏ÄOS„Éê„Éº„Ç∏„Éß„É≥„ÅØ„Ç≠„É£„ÉÉ„Ç∑„É•Âà©Áî®
const profileCache = {};

async function loadDeviceProfile(device) {
    if (!device || !device.target || !device.id) return false;
    const version = app.selectedVersion;
    const targetPath = device.target;
    const profileId = device.id;
    const cacheKey = `${version}::${targetPath}::${profileId}`;

    // URLË®≠ÂÆö„ÇíÁ¢∫Ë™çÔºàÈÄöÂ∏∏„ÅØloadVersions„ÅßË®≠ÂÆöÊ∏à„Åø„Å†„ÅåÂøµ„ÅÆ„Åü„ÇÅÔºâ
    setupVersionUrls(version);
    
    const profilesUrl = `${config.image_urls[version]}/targets/${targetPath}/profiles.json`;
    // „Ç≠„É£„ÉÉ„Ç∑„É•ÂëΩ‰∏≠ÊôÇ„ÅØÂç≥Âà©Áî®
    if (profileCache[cacheKey]) {
        console.log(`Using cached profile for ${cacheKey}`);
        applyProfileData(profileCache[cacheKey], profileId);
        Promise.allSettled([ fetchDevicePackages() ])
            .then(() => console.log('Background tasks completed (from cache)'));
        return true;
    }

    // ÂàùÂõû„ÅØÂøÖ„ÅöDL
    try {
        console.log(`Loading profile from: ${profilesUrl}`);
        const response = await fetch(profilesUrl, { cache: 'no-cache' });
        
        if (!response.ok) {
            if (response.status === 404) {
                // „Éê„Éº„Ç∏„Éß„É≥„ÅØÂ≠òÂú®„Åô„Çã„Åå„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅåÁÑ°„ÅÑÔºàÊúüÂæÖ„Åï„Çå„ÇãÂãï‰ΩúÔºâ
                console.log(`Device ${device.id} not supported in version ${version}`);
                hideDeviceInfo();
                current_device = {};
                return false;
            }
            // 404‰ª•Â§ñ„ÅÆHTTP„Ç®„É©„Éº„ÅØÊú¨ÂΩì„ÅÆ„Ç®„É©„Éº
            throw new Error(`Failed to fetch profiles.json: HTTP ${response.status}`);
        }
        
        const profilesData = await response.json();
        console.log(`Loaded profiles data:`, profilesData);
        profileCache[cacheKey] = profilesData;
        applyProfileData(profilesData, profileId);

        // „Éë„ÉÉ„Ç±„Éº„Ç∏ÂèñÂæóÂÆå‰∫Ü„ÇíÂæÖ„Å£„Å¶„Åã„ÇâÊèèÁîªÔºàSNAPSHOTÁâà„ÅØÂà•Âá¶ÁêÜÔºâ
        try {
            await fetchDevicePackages();
        } catch (e) {
            console.error('fetchDevicePackages failed:', e);
        }
        // ÂèñÂæóÂÆå‰∫ÜÂæå„Å´„Å†„Åë UI ÁîüÊàêÔºàSNAPSHOT„Åß„ÇÇÂÆüË°å„Åï„Çå„ÇãÔºâ
        if (typeof generatePackageSelector === 'function') {
            generatePackageSelector();
        }
        return true;
        
    } catch (error) {
        // CORS„Ç®„É©„ÉºÔºàÂè§„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅßÊúüÂæÖ„Åï„Çå„ÇãÂãï‰ΩúÔºâ
        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            console.log(`Version ${version} access blocked by CORS - Expected for older versions`);
            hideDeviceInfo();
            current_device = {};
            return false;
        }
        
        // „Åù„Çå‰ª•Â§ñ„ÅØÊú¨ÂΩì„ÅÆ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº
        console.error('Network error loading device profile:', error);
        hideDeviceInfo();
        current_device = {};
        return false;
    }
}

async function applyProfileData(profilesData, profileId) {
    app.versionCode = profilesData.version_code || '';
    
    if (profilesData.linux_kernel) {
        const lk = profilesData.linux_kernel;
        app.kernelHash = `${lk.version}-${lk.release}-${lk.vermagic}`;
        console.log('[Kernel] From profiles.json:', app.kernelHash);
    } else {
        console.log('[Kernel] No linux_kernel in profiles.json, fetching from server...');
        app.kernelHash = await fetchActualKernelHash(app.selectedVersion, current_device.target);
        console.log('[Kernel] From server HTML:', app.kernelHash);
    }
    async function fetchActualKernelHash(version, targetPath) {
        try {
            setupVersionUrls(version);
            const kmodsUrl = `${config.image_urls[version]}targets/${targetPath}/kmods/`;
        
            const response = await fetch(kmodsUrl, { cache: 'no-cache' });
            if (!response.ok) {
                console.log(`[Kernel] kmods directory not found: ${response.status}`);
                return null;
            }
        
            const html = await response.text();
            console.log('[Kernel] Fetched HTML from:', kmodsUrl);
        
            return await selectKernelSmart(html);
            
        } catch (error) {
            console.log('[Kernel] Failed to fetch kernel hash:', error.message);
            return null;
        }
    }
    
    async function selectKernelSmart(html) {
        // ÂÖ®„Å¶„ÅÆ„Ç´„Éº„Éç„É´„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊäΩÂá∫
        const kernelDirs = extractAllKernels(html);
        
        if (kernelDirs.length === 0) {
            console.log('[Kernel] No valid kernel directories found');
            return null;
        } else if (kernelDirs.length === 1) {
            // Âçò‰∏Ä„Ç´„Éº„Éç„É´ ‚Üí Âç≥Êé°Áî®ÔºàÂäπÁéáÂåñÔºâ
            console.log('[Kernel] Single kernel found:', kernelDirs[0].hash);
            return kernelDirs[0].hash;
        } else {
            // Ë§áÊï∞„Ç´„Éº„Éç„É´ ‚Üí Êó•‰ªò„ÅßÊúÄÊñ∞ÈÅ∏Êäû
            console.log(`[Kernel] Multiple kernels found (${kernelDirs.length}), selecting latest by date`);
            return selectLatestByDate(kernelDirs);
        }
    }
    
    function extractAllKernels(html) {
        const tableRowPattern = /<tr><td class="n"><a href="([^"\/]+)\/"[^>]*>([^<]+)<\/a>\/[^<]*<\/td><td class="s">[^<]*<\/td><td class="d">([^<]+)<\/td>/g;
        const kernelDirs = [];
        let match;
        
        while ((match = tableRowPattern.exec(html)) !== null) {
            const dirName = match[1];
            const dateStr = match[3];
            
            // "." „ÇÑ ".." „Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÈô§Â§ñ
            if (dirName === '.' || dirName === '..') continue;
            
            // „Ç´„Éº„Éç„É´„Éè„ÉÉ„Ç∑„É•ÂΩ¢Âºè„ÅÆÊ§úË®º
            if (dirName.match(/^\d+\.\d+\.\d+-\d+-[a-f0-9]{32}$/)) {
                try {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        kernelDirs.push({
                            hash: dirName,
                            date: date,
                            dateStr: dateStr
                        });
                    }
                } catch (e) {
                    console.log(`[Kernel] Invalid date format: ${dateStr}`);
                }
            }
        }
        
        return kernelDirs;
    }
    
    function selectLatestByDate(kernelDirs) {
        // Êó•‰ªò„Åß„ÇΩ„Éº„Éà„Åó„Å¶ÊúÄÊñ∞„ÇíÈÅ∏Êäû
        kernelDirs.sort((a, b) => b.date - a.date);
        const latestKernel = kernelDirs[0];
        
        console.log(`[Kernel] Selected latest kernel: ${latestKernel.hash} (${latestKernel.dateStr})`);
        
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊÉÖÂ†±„ÇÇ‰øùÂ≠òÔºà„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„Å´‰ΩøÁî®Ôºâ
        if (kernelDirs.length > 1) {
            app.snapshotKernelFallbacks = kernelDirs.slice(1, 3).map(k => k.hash);
            console.log(`[Kernel] Fallback kernels available: ${app.snapshotKernelFallbacks.join(', ')}`);
        }
        
        return latestKernel.hash;
    }

    if (profilesData.profiles && profilesData.profiles[profileId]) {
        const profile = profilesData.profiles[profileId];
        const defaultPackages = profilesData.default_packages || [];
        const devicePackages = profile.device_packages || [];
        const asuExtraPackages = ['luci'];
        
        // „Çª„É¨„ÇØ„Çø„Éº„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Åï„Çå„Å¶„ÅÑ„Çã„Éë„ÉÉ„Ç±„Éº„Ç∏„ÇÇÂèéÈõÜ
        const checkedPackages = [];
        document.querySelectorAll('.package-selector-checkbox:checked').forEach(cb => {
            const pkgName = cb.getAttribute('data-package');
            if (pkgName) {
                checkedPackages.push(pkgName);
            }
        });
        
        // ÂÖ®„Éë„ÉÉ„Ç±„Éº„Ç∏„ÇíÁµ±ÂêàÔºàÈáçË§áÈô§ÂéªÔºâ
        const allPackages = Array.from(new Set([
            ...defaultPackages,
            ...devicePackages,
            ...asuExtraPackages,
            ...checkedPackages
        ]));
        
        document.getElementById('asu-packages').value = allPackages.join(' ');
        asuCollectPackages();
    }
}
       
function showDeviceInfo() {
    ErrorHandler.trace('showDeviceInfo', current_device);
    if (!current_device || !current_device.id) return;

    const device = app.devices.find(d => d.id === current_device.id && d.target === current_device.target);
    if (!device) return;
    
    // „Éê„Éº„Ç∏„Éß„É≥Áï™Âè∑„ÅÆÂèñÂæóÔºà„Éì„É´„ÉâÁï™Âè∑Âê´„ÇÄÔºâ
    let fullVersion = app.selectedVersion;
    let displayVersionCode = app.versionCode || 'null';  // versionCode„ÅåÁÑ°„ÅÑÂ†¥Âêà„ÅØ„Äånull„Äç„ÇíË°®Á§∫
    if (app.versionCode) {
        fullVersion = `${app.selectedVersion} (${app.versionCode})`;
    }
    
    // URLË®≠ÂÆö„ÇíÁ¢∫Ë™ç
    setupVersionUrls(app.selectedVersion);
    
    // URLsÁîüÊàê
    const imageFolder = `${config.image_urls[app.selectedVersion]}targets/${device.target}`;
    
    const deviceLink = `${window.location.origin}${window.location.pathname}?version=${encodeURIComponent(app.selectedVersion)}&target=${encodeURIComponent(device.target)}&id=${encodeURIComponent(device.id)}`;
    
    const infoUrl = (config.info_url || "")
        .replace("{title}", encodeURI(getDeviceTitle(device)))
        .replace("{target}", device.target)
        .replace("{id}", device.id)
        .replace("{version}", app.selectedVersion);

    // ===== About this build Ë°®Á§∫Áî® ÂâçÂá¶ÁêÜ„Éñ„É≠„ÉÉ„ÇØ =====
    const {
        country = 'unknown',
        timezone = 'unknown',
        isp = 'unknown',
        as: asNumber = 'unknown',
        ipv4 = '',
        ipv6 = '',
        aftr,
        mape,
        notice = ''
    } = window.cachedApiInfo || {};

    const countryValue = country;
    const zoneValue    = timezone;
    const ispValue     = isp;
    const asValue      = asNumber;
    const ipAddressValue = [ipv4, ipv6].filter(Boolean).join(' / ') || 'unknown';

    // ‚ñº WAN Ë°®Á§∫„Çí Connection modeÔºètype „Å´Âêà„Çè„Åõ„Å¶ÂãïÁöÑÂ§âÊõ¥
    const connMode = document.querySelector('input[name="connectionMode"]:checked')?.value || 'auto';
    const connType = document.querySelector('input[name="connectionType"]:checked')?.value || '';
    let wanType = 'Unknown';

    if (connMode === 'manual') {
        switch (connType) {
            case 'dhcp':
                wanType = 'Manual (DHCP)';
                break;
            case 'pppoe':
                wanType = 'Manual (PPPoE)';
                break;
            case 'dslite':
                wanType = 'Manual (DS-Lite)';
                break;
            case 'mape':
                wanType = 'Manual (MAP-E)';
                break;
            case 'ap':
                wanType = 'Manual (AP)';
                break;
            default:
                wanType = 'Manual (Unknown)';
        }
    } else {
        // Auto: API Ê§úÂá∫ÁµêÊûú„ÇíÂèçÊò†
        if (aftr) {
            wanType = 'Auto (DS-Lite)';
        } else if (mape) {
            wanType = 'Auto (MAP-E)';
        } else {
            wanType = 'Auto (DHCP/PPPoE)';
        }
    }

    const noticeValue = notice.trim();
    
    // ÂÖ¨ÂºèÂΩ¢Âºè„ÅÆAbout this build„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÊßãÁØâÔºàAfterÔºâ
    const infoHtml = `
        <h5>About this build</h5>
        <div class="row">
            <span class="col1">Model</span>
            <span class="col2" id="image-model"><strong>${getDeviceTitle(device)}</strong></span>
        </div>
        <div class="row">
            <span class="col1">Target</span>
            <span class="col2" id="image-target">${device.target}</span>
        </div>
        <div class="row">
            <span class="col1">Version</span>
            <span class="col2">
                <span id="image-version">${app.selectedVersion}</span>
                (<span id="image-code">${displayVersionCode}</span>)
            </span>
        </div>
        <div class="row">
            <span class="col1">Country</span>
            <span class="col2" id="image-country">${countryValue}</span>
        </div>
        <div class="row">
            <span class="col1">Zone</span>
            <span class="col2" id="image-zone">${zoneValue}</span>
        </div>
        <div class="row">
            <span class="col1">ISP</span>
            <span class="col2" id="image-isp">${ispValue}</span>
        </div>
        <div class="row">
            <span class="col1">AS</span>
            <span class="col2" id="image-as">${asValue}</span>
        </div>
        <div class="row">
            <span class="col1">IP Address</span>
            <span class="col2" id="image-ip-address">${ipAddressValue}</span>
        </div>
        <div class="row">
            <span class="col1">WAN</span>
            <span class="col2" id="wan-type">${wanType}</span>
        </div>
        <div class="row">
            <span class="col1">Notice</span>
            <span class="col2" id="image-notice">${noticeValue}</span>
        </div>
        <div class="row">
            <span class="col1">Links</span>
            <span class="col2">
                <a id="image-folder" href="${imageFolder}" title="Browse image folder" target="_blank"></a>
                <a id="image-info" href="${infoUrl}" title="Device info" target="_blank"></a>
                <a id="image-link" href="#" title="Copy link" onclick="navigator.clipboard.writeText('${deviceLink}').then(() => alert('Link copied!')); return false;"></a>
            </span>
        </div>
    `;
    
    document.getElementById('info').innerHTML = infoHtml;
    document.getElementById('info').style.display = 'block';
    document.getElementById('packages').style.display = 'block';
    document.getElementById('request-build').style.display = 'inline-block';

// „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÊúÄÂàù„Å´Ë®≠ÂÆöÔºà„Åæ„Å†Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
    const textarea = document.getElementById('uci-defaults-content');
    if (!app.templateLoaded && (!textarea.value || textarea.value.trim() === '')) {
        textarea.value = SETUP_SH_TEMPLATE;
        app.templateLoaded = true;
        console.log('Template loaded for the first time');
    }
}

function hideDeviceInfo() {
    ErrorHandler.debug('hideDeviceInfo', 'Before hiding');
    document.getElementById('info').style.display = 'none';
    document.getElementById('packages').style.display = 'none';
    document.getElementById('request-build').style.display = 'none';
    ErrorHandler.debug('hideDeviceInfo', 'After hiding', {
        infoDisplay: document.getElementById('info').style.display
    });
    
    // Áµ±Âêà„Éá„Éê„ÉÉ„Ç∞„Åß„ÅÆÁäØ‰∫∫ÁâπÂÆö
    setTimeout(() => {
        const infoEl = document.getElementById('info');
        if (infoEl.style.display !== 'none') {
            ErrorHandler.debug('hideDeviceInfo', 'CULPRIT FOUND! Display changed to: ' + infoEl.style.display);
        }
    }, 100);
}

// ==================== auto „Éà„É™„Ç¨„ÉºÈñ¢Êï∞ ====================
let apiInfoFetched = false;  // ÈáçË§áÈò≤Ê≠¢Áî®„Éï„É©„Ç∞

/*
async function handleAsuDetailsToggle(e) {
    const details = e.target;
    
    if (details.open && !window.apiInfoFetched) {
        window.apiInfoFetched = true;  // „Ç∞„É≠„Éº„Éê„É´„Éï„É©„Ç∞
        
        try {
            await fetchApiInfoAndUpdate();
            updateRequiredPackages();
            asuCollectPackages();
        } catch (error) {
            window.apiInfoFetched = false;  // Â§±ÊïóÊôÇ„É™„Çª„ÉÉ„Éà
            // „Ç®„É©„ÉºÂá¶ÁêÜ
        }
    }
}
*/

// ==================== Êé•Á∂öË®≠ÂÆöÂ§âÊõ¥ÂèçÊò†Èñ¢Êï∞ ====================
function applyConnectionSettingsChange() {
    updateGuaSectionVisibility();
    applyInitialsFromApi(document.querySelector('input[name="connectionType"]:checked')?.value || '');
    // ÁµÇÁÇπ„É≠„Ç∏„ÉÉ„ÇØ„Å∏
    syncTemplateAndPackages({ trigger: 'connection-change' });
    showDeviceInfo();
}

// ==================== Êé•Á∂öË®≠ÂÆö„Éè„É≥„Éâ„É©„Éº ====================
function handleConnectionModeChange(e) {
    const manualSection = document.getElementById('manual-connection-section');
    const ispDetectionGroup = document.getElementById('isp-detection-group');
    
    // Auto „Å´Êàª„Å£„ÅüÊôÇ„ÄÅÂÖ®„Å¶„ÅÆÊé•Á∂ö„Çø„Ç§„ÉóË®≠ÂÆö„ÇíÁ¢∫ÂÆü„Å´ÈùûË°®Á§∫
    const pppoeSection = document.getElementById('pppoe-section');
    const dsliteSection = document.getElementById('dslite-section');
    const mapeManualSection = document.getElementById('mape-manual-section');
    const apSection = document.getElementById('ap-section');
    
    if (e.target.value === 'manual') {
        manualSection.style.display = 'block';
        // ManualÊôÇ„ÅØISP Detection Status„ÇíÈùûË°®Á§∫
        if (ispDetectionGroup) {
            ispDetectionGroup.style.display = 'none';
        }
    } else {
        // AutoÈÅ∏ÊäûÊôÇ
        manualSection.style.display = 'none';
        
        // ÂÖ®„Å¶„ÅÆÊé•Á∂ö„Çø„Ç§„ÉóÂõ∫ÊúâË®≠ÂÆö„ÇíÈùûË°®Á§∫
        if (pppoeSection) pppoeSection.style.display = 'none';
        if (dsliteSection) dsliteSection.style.display = 'none';
        if (mapeManualSection) mapeManualSection.style.display = 'none';
        if (apSection) apSection.style.display = 'none';
        
        // AutoÊôÇ„ÅØISP Detection Status„ÇíË°®Á§∫
        if (ispDetectionGroup) {
            ispDetectionGroup.style.display = 'block';
        }
    }
    
    applyConnectionSettingsChange();
}

function handleConnectionTypeChange(e) {
    const pppoeSection = document.getElementById('pppoe-section');
    const dsliteSection = document.getElementById('dslite-section');
    const mapeManualSection = document.getElementById('mape-manual-section');
    const apSection = document.getElementById('ap-section');
    
    pppoeSection.style.display = 'none';
    dsliteSection.style.display = 'none';
    mapeManualSection.style.display = 'none';
    if (apSection) apSection.style.display = 'none';
    
    // API„Éá„Éº„ÇøÂèñÂæó
    const apiInfo = window.cachedApiInfo || {};
    const hasAftr = !!(apiInfo.mape && apiInfo.mape.aftrIpv6Address);
    const hasMape = !!(apiInfo.mape && apiInfo.mape.brIpv6Address);
    
    if (e.target.value === 'pppoe') {
        pppoeSection.style.display = 'block';
    } else if (e.target.value === 'dslite') {
        dsliteSection.style.display = 'block';
        
        // DS-Lite: AFTR„Éá„Éº„Çø„ÅÆÊúâÁÑ°„ÅßAuto/ManualÂà∂Âæ°
        const dsliteAuto = document.getElementById('dslite-auto');
        const dsliteManual = document.getElementById('dslite-manual');
        const dsliteHint = document.getElementById('dslite-mode-hint');
        
        if (hasAftr) {
            // AFTR„Éá„Éº„Çø„ÅÇ„ÇäÔºöAutoÊúâÂäπÔºàÂàùÊúüÈÅ∏ÊäûÔºâ
            dsliteAuto.disabled = false;
            dsliteAuto.checked = true;
            dsliteManual.checked = false;
            if (dsliteHint) dsliteHint.textContent = 'Auto: Use ISP-detected AFTR address | Manual: Specify AFTR settings manually';
        } else {
            // AFTR„Éá„Éº„Çø„Å™„ÅóÔºöAutoÁÑ°Âäπ„ÄÅManualÂº∑Âà∂
            dsliteAuto.disabled = true;
            dsliteAuto.checked = false;
            dsliteManual.checked = true;
            if (dsliteHint) dsliteHint.textContent = 'Auto not available (no AFTR detected) | Manual configuration required';
        }
        
        // ManualË®≠ÂÆö„Ç®„É™„Ç¢„ÅÆË°®Á§∫Âà∂Âæ°
        const manualConfig = document.getElementById('dslite-manual-config');
        if (manualConfig) {
            manualConfig.style.display = hasAftr ? 'none' : 'block';
        }
        
} else if (e.target.value === 'mape') {
        mapeManualSection.style.display = 'block';
        
        // MAP-E: BR„Éá„Éº„Çø„ÅÆÊúâÁÑ°„ÅßAuto/ManualÂà∂Âæ°
        const mapeAuto = document.getElementById('mape-auto');
        const mapeGua = document.getElementById('mape-gua');
        const mapePd = document.getElementById('mape-pd');
        
        if (hasMape) {
            // MAP-E„Éá„Éº„Çø„ÅÇ„ÇäÔºöAutoÊúâÂäπÔºàÂàùÊúüÈÅ∏ÊäûÔºâ
            mapeAuto.disabled = false;
            mapeAuto.checked = true;
            if (mapeGua) mapeGua.checked = false;
            if (mapePd) mapePd.checked = false;
        } else {
            // MAP-E„Éá„Éº„Çø„Å™„ÅóÔºöAutoÁÑ°Âäπ„ÄÅGUAÈÅ∏Êäû
            mapeAuto.disabled = true;
            mapeAuto.checked = false;
            if (mapeGua) {
                mapeGua.checked = true;
            } else if (mapePd) {
                mapePd.checked = true;
            }
        }
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•Á¢∫Ë™ç„Åó„Å¶„Åã„ÇâÂøÖË¶ÅÊôÇ„ÅÆ„Åø„É≠„Éº„Éâ
        if (mapShCache === undefined) {
            // Êú™„É≠„Éº„Éâ„ÅÆÂ†¥Âêà„ÅÆ„ÅøÈùûÂêåÊúü„Åß„É≠„Éº„Éâ
            (async () => {
                try {
                    await loadMapSh();
                } catch (err) {
                    console.error('map.sh load failed:', err);
                }
                applyConnectionSettingsChange();
            })();
            return; // ÈùûÂêåÊúüÂá¶ÁêÜÂÆå‰∫ÜÂæå„Å´ÂèçÊò†„Åô„Çã„ÅÆ„Åß„Åì„Åì„ÅßÊäú„Åë„Çã
        }
        // Êó¢„Å´„Ç≠„É£„ÉÉ„Ç∑„É•Ê∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„ÅæÁ∂öË°å
    } else if (e.target.value === 'ap') {
        if (apSection) apSection.style.display = 'block';
    }
    
    applyConnectionSettingsChange();
}

function handleMapeTypeChange(e) {
    applyConnectionSettingsChange();
}

function handleDsliteModeChange(e) {
    const manualConfig = document.getElementById('dslite-manual-config');
    const aftrAddressField = document.getElementById('dslite-aftr-address');
    
    if (e.target.value === 'manual') {
        manualConfig.style.display = 'block';
        applyInitialsFromApi('dslite');
    } else {
        manualConfig.style.display = 'none';
        if (window.cachedApiInfo && window.cachedApiInfo.mape && window.cachedApiInfo.mape.aftrIpv6Address) {
            aftrAddressField.value = window.cachedApiInfo.mape.aftrIpv6Address;
        }
    }
    
    applyConnectionSettingsChange();
}

function isGlobalUnicastIPv6(ip) {
    if (!ip) return false;
    // GUA: 2000::/3 (starts with 2xxx or 3xxx), exclude ULA (fd00::/8) and link-local (fe80::/10)
    const norm = String(ip).trim().toLowerCase();
    return /^(2|3)[0-9a-f]/.test(norm) && !/^fd/.test(norm) && !/^fe8/.test(norm);
}

function updateGuaSectionVisibility() {
    const guaSection = document.getElementById('mape-gua-section');
    const mapeType = document.querySelector('input[name="mapeType"]:checked')?.value || 'auto';
    const connectionMode = document.querySelector('input[name="connectionMode"]:checked')?.value || 'auto';
    const connectionType = document.querySelector('input[name="connectionType"]:checked')?.value || 'dhcp';

    const api = window.cachedApiInfo || {};
    const apiMape = api.mape || {};
    const apiIPv6 = api.ipv6 || '';
    const hasGua = isGlobalUnicastIPv6(apiIPv6);

    // Âé≥ÂØÜÊù°‰ª∂:
    // - MAP-E„ÅåÂØæË±°
    // - PD„Åß„ÅØÁµ∂ÂØæ„Å´Ë°®Á§∫„Åó„Å™„ÅÑ
    // - Auto: API„ÅßMAP-E„ÅåÊ§úÂá∫„Åï„Çå„ÄÅ„Åã„Å§ GUA „Ç¢„Éâ„É¨„Çπ„Åå„ÅÇ„ÇãÊôÇ„ÅÆ„Åø
    // - Manual: mapeType „Åå 'gua' „ÅÆÊôÇ„ÅÆ„ÅøÔºà'auto' „ÅÆÂ†¥Âêà„ÅØ API Ë¶Å‰ª∂„ÇíÊ∫Ä„Åü„ÅôÊôÇÔºâ
    let shouldShow = false;

    if (connectionType === 'mape') {
        if (connectionMode === 'auto') {
            shouldShow = !!apiMape.brIpv6Address && hasGua;
        } else {
            if (mapeType === 'gua') {
                shouldShow = true;
            } else if (mapeType === 'auto') {
                shouldShow = !!apiMape.brIpv6Address && hasGua;
            } else { // 'pd'
                shouldShow = false;
            }
        }
    }

    if (guaSection) {
        guaSection.style.display = shouldShow ? 'block' : 'none';
    }

    // ÂÄ§„ÅÆËá™ÂãïË®≠ÂÆö„ÅØË°®Á§∫„ÅåÊ±∫„Åæ„Å£„ÅüÂæå„ÄÅÊú™ÂÖ•ÂäõÊôÇ„ÅÆ„Åø
    if (shouldShow) {
        const guaInput = document.getElementById('mape-gua-prefix');
        if (guaInput && !guaInput.value) {
            const guaPrefix = calculateGuaPrefixFromApi();
            if (guaPrefix) guaInput.value = guaPrefix;
        }
    }
}

// ==================== „Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„ÇπË®àÁÆóÂÖ±ÈÄöÈñ¢Êï∞ ====================
function calculatePrefix(ipv6, length = 64) {
    if (!ipv6) return '';
    const segments = ipv6.split(':');
    if (segments.length >= 4) {
        const prefix = segments.slice(0, 4).join(':');
        return `${prefix}::/${length}`;
    }
    return '';
}

// API„ÅÆIPv6„Ç¢„Éâ„É¨„Çπ„Åã„ÇâGUA„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆó
function calculateGuaPrefixFromApi() {
    return calculatePrefix(window.cachedApiInfo?.ipv6 || '', 64);
}
        
// ==================== „Éï„Ç©„Éº„É†ÂàùÊúüÂÄ§Ê≥®ÂÖ•ÂÖ±ÈÄöÈñ¢Êï∞ ====================
function setIfEmpty(id, value) {
    const el = document.getElementById(id);
    if (el && !el.value && value != null && value !== '') {
        el.value = value;
    }
}

// ==================== ISPÊÉÖÂ†±Ë°®Á§∫ÊßãÁØâÂÖ±ÈÄöÈñ¢Êï∞ ====================
function buildIspStatus(apiInfo) {
    if (!apiInfo) {
        return {
            status: 'Auto-detection failed',
            details: 'API connection error or unsupported ISP\nManual configuration required.'
        };
    }

    let statusText = 'Auto-detection successful';
    let details = '';

    if (apiInfo.isp) details += `ISP: ${apiInfo.isp}\n`;
    if (apiInfo.country) {
        details += `Country/Region: ${apiInfo.country}`;
        if (apiInfo.regionName) details += ` (${apiInfo.regionName})`;
        details += '\n';
    }
    if (apiInfo.timezone) details += `Timezone: ${apiInfo.timezone}\n`;

    if (apiInfo.mape) {
        if (apiInfo.mape.aftrType) {
            statusText += ' - DS-Lite support detected';
            details += `\n[DS-Lite Configuration]\n`;
            details += `aftrType: ${apiInfo.mape.aftrType}\n`;
            if (apiInfo.mape.aftrIpv6Address) {
                details += `aftrIpv6Address: ${apiInfo.mape.aftrIpv6Address}\n`;
            }
        } else if (apiInfo.mape.brIpv6Address) {
            statusText += ' - MAP-E support detected';
            details += `\n[MAP-E Configuration]\n`;
            details += `brIpv6Address: ${apiInfo.mape.brIpv6Address}\n`;
            details += `eaBitLength: ${apiInfo.mape.eaBitLength}\n`;
            details += `ipv4Prefix: ${apiInfo.mape.ipv4Prefix}\n`;
            details += `ipv4PrefixLength: ${apiInfo.mape.ipv4PrefixLength}\n`;
            details += `ipv6Prefix: ${apiInfo.mape.ipv6Prefix}\n`;
            details += `ipv6PrefixLength: ${apiInfo.mape.ipv6PrefixLength}\n`;
            details += `psIdOffset: ${apiInfo.mape.psIdOffset}\n`;
            details += `psidlen: ${apiInfo.mape.psidlen}\n`;
        }
    } else {
        statusText += ' - DHCP/PPPoE environment';
        details += '\nStandard DHCP or PPPoE connection environment detected.';
    }

    const formatted = details
        .split('\n')
        .map(line => `<div>${line}</div>`)
        .join('');

    return { status: statusText, details: formatted };
}

// ==================== ISPÊÉÖÂ†±Èñ¢ÈÄ£ ====================
async function fetchApiInfoAndUpdate() {
    try {
        updateIspDisplay('Fetching', 'Retrieving ISP information...');
        const apiInfo = await fetchApiInfo();
        window.cachedApiInfo = apiInfo;
        if (apiInfo) {
            // Country „Å® TimezoneÔºàÁ©∫Ê¨Ñ„ÅÆ„ÅøË®≠ÂÆöÔºâ
            setIfEmpty('aios-country', apiInfo.country);
            setIfEmpty('aios-zonename', apiInfo.timezone);

            // ISPË°®Á§∫„ÅØÂÖ±ÈÄöÈñ¢Êï∞„ÅßÊßãÁØâ
            const isp = buildIspStatus(apiInfo);
            updateIspDisplay(isp.status, isp.details);

            // MAP-EÊ§úÂá∫ÊôÇ„ÅÆ„Åømap.shË™≠„ÅøËæº„Åø
            if (apiInfo.mape && apiInfo.mape.brIpv6Address) {
                await loadMapSh();
            }

            // GUA „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
            updateGuaSectionVisibility();

            // „Ç¶„Ç£„Ç∂„Éº„Éâ„ÅÆON/OFF„Å´Èñ¢‰øÇ„Å™„Åè„ÄÅÁ©∫Ê¨Ñ„Å´„ÅØÂàùÊúüÂÄ§„ÇíÊ≥®ÂÖ•Ôºà‰∏äÊõ∏„Åç„ÅØ„Åó„Å™„ÅÑÔºâ
            // MAP-EÊÉÖÂ†±
            if (apiInfo.mape && apiInfo.mape.brIpv6Address) {
                setIfEmpty('mape-br', apiInfo.mape.brIpv6Address);
                setIfEmpty('mape-ealen', apiInfo.mape.eaBitLength || '');
                setIfEmpty('mape-ipv4-prefix', apiInfo.mape.ipv4Prefix || '');
                setIfEmpty('mape-ipv4-prefixlen', apiInfo.mape.ipv4PrefixLength || '');
                setIfEmpty('mape-ipv6-prefix', apiInfo.mape.ipv6Prefix || '');
                setIfEmpty('mape-ipv6-prefixlen', apiInfo.mape.ipv6PrefixLength || '');
                setIfEmpty('mape-psid-offset', apiInfo.mape.psIdOffset || '');
                setIfEmpty('mape-psidlen', apiInfo.mape.psidlen || '');
            }
            
            // DS-LiteÊÉÖÂ†±ÔºàÁ©∫Ê¨Ñ„ÅÆ„ÅøË®≠ÂÆö„ÄÅÊó¢Â≠òÂÄ§„ÅØ‰øùË≠∑Ôºâ
            if (apiInfo.mape && apiInfo.mape.aftrType) {
                setIfEmpty('dslite-aftr-type', apiInfo.mape.aftrType);
                setIfEmpty('dslite-aftr-address', apiInfo.mape.aftrIpv6Address);
            }
            
        } else {
            updateIspDisplay(
                'Auto-detection failed',
                'API connection error or unsupported ISP\nManual configuration required.'
            );
        }

    } catch (error) {
        console.error('ISP info fetch error:', error);
        updateIspDisplay(
            'Fetch error',
            'API connection failed.\nPlease use manual configuration for offline environments.'
        );
    }
}
        
function updateIspDisplay(status, details) {
    const statusMessage = document.getElementById('isp-status-message');
    const technicalInfo = document.getElementById('isp-technical-info');

    statusMessage.textContent = status;

    if (details) {
        technicalInfo.innerHTML = details;
        technicalInfo.style.display = 'block';
    } else {
        technicalInfo.style.display = 'none';
    }
}

async function fetchApiInfo() {
    const apis = [
        'https://auto-config.site-u.workers.dev/',
        'https://site-u2023.github.io/api/auto-config/'  // „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
    ];
    
    for (const apiUrl of apis) {
        try {
            
            // „Ç≠„É£„ÉÉ„Ç∑„É•ÁÑ°ÂäπÂåñÁî®„ÅÆ„É©„É≥„ÉÄ„É†„Éë„É©„É°„Éº„Çø„ÇíËøΩÂä†
            const cacheBreaker = `?_t=${Date.now()}&_r=${Math.random()}`;
            const finalUrl = apiUrl + cacheBreaker;
            
            const response = await fetch(finalUrl, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                },
                timeout: 10000  // 10Áßí„Çø„Ç§„É†„Ç¢„Ç¶„Éà
            });
            
            console.log(`API response status (${apiUrl}):`, response.status);
            
            if (!response.ok) {
                console.warn(`API access failed with status: ${response.status} (${apiUrl})`);
                continue;  // Ê¨°„ÅÆAPI„ÇíË©¶Ë°å
            }
            
            const data = await response.json();
            
            // ‰∫íÊèõ„É©„ÉÉ„Éë„Éº: Êñ∞Êóß„Å©„Å°„Çâ„ÅÆ„Ç≠„Éº„Åß„ÇÇÂãï„Åè„Çà„ÅÜ„Å´Áõ∏‰∫í„Ç≥„Éî„Éº
            if (data) {
                if (data.rule && data.mape === undefined) {
                    data.mape = data.rule;
                }
                if (data.mape && data.rule === undefined) {
                    data.rule = data.mape;
                }
            }
            
            // console.log(`API Info fetched successfully from ${apiUrl}:`, data);
            return data;
            
        } catch (error) {
            console.error(`Failed to fetch from ${apiUrl}:`, error);
            // Ê¨°„ÅÆAPI„ÇíË©¶Ë°å
        }
    }
    
    console.error('All API endpoints failed');
    return null;
}

// ==================== „ÉÜ„É≥„Éó„É¨ÊñáÂ≠óÂàó„ÅÆÂ§âÊï∞Ë®≠ÂÆöÂÖ±ÈÄöÈñ¢Êï∞ ====================
function setVariableDefinitions(content, variables) {
    const variableLines = [];
    
    for (const [key, config] of Object.entries(variables)) {
        if (!config || typeof config !== 'object') continue;
        
        const { value, active } = config;
        const safeValue = (value === undefined || value === null) ? '' : String(value).trim();
        
        // active„Ååtrue„ÅßÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÂ§âÊï∞„ÇíÂÆöÁæ©
        if (active && safeValue !== '') {
            variableLines.push(`${key}="${safeValue}"`);
        }
    }
    
    const variableText = variableLines.length > 0 ? variableLines.join('\n') : '';
    const managedRegion = /(# BEGIN_VARIABLE_DEFINITIONS\n)([\s\S]*?)(# END_VARIABLE_DEFINITIONS\n)/;
    
    return content.replace(managedRegion, `$1${variableText ? variableText + '\n' : ''}$3`);
}

// ==================== „ÉÜ„É≥„Éó„É¨„Éº„ÉàË®≠ÂÆö ====================
async function updateConfiguredTemplate() {
    try {
        let content = document.getElementById('uci-defaults-content').value;

    if (!content || content.trim() === '' || content.includes('Failed to load setup.sh template')) {
        content = SETUP_SH_TEMPLATE;
        app.templateLoaded = true;
    } else if (!app.templateLoaded) {
        // ÂàùÊúüË°®Á§∫ÊôÇ„Å´„ÉÜ„É≥„Éó„É¨„ÅåÊú™Ë®≠ÂÆö„Å™„ÇâÂøÖ„ÅöÈÅ©Áî®
        document.getElementById('uci-defaults-content').value = SETUP_SH_TEMPLATE;
        app.templateLoaded = true;
    }

        const config = getAiosConfig();
        const apiInfo = window.cachedApiInfo || null;  // „Ç≠„É£„ÉÉ„Ç∑„É•„ÅÆ„Åø„ÄÅAPIÂëº„Å≥Âá∫„ÅóÂâäÈô§

        const selectedPackages = new Set(split(document.getElementById('asu-packages').value));
        const customized = await customizeSetupScript(content, config, apiInfo, selectedPackages);
        document.getElementById('uci-defaults-content').value = customized;
    } catch (error) {
        console.error('Template update error:', error);
    }
}

async function customizeSetupScript(content, userConfig, apiInfo, selectedPackages) {
    let customized = content;

    // API„Éô„Éº„Çπ„ÅÆÊé®Â•®ÂÄ§
    const api = apiInfo?.mape || {};
    const apiHasDslite = !!api.aftrIpv6Address;
    const apiHasMape = !!api.brIpv6Address;

    // MAP-E ÂÄôË£úÂÄ§
    const mapeVals = {
        br: userConfig.mapeBr || (apiHasMape ? api.brIpv6Address : ''),
        ealen: userConfig.mapeEalen || (apiHasMape ? api.eaBitLength : ''),
        v4p: userConfig.mapeIpv4Prefix || (apiHasMape ? api.ipv4Prefix : ''),
        v4l: userConfig.mapeIpv4Prefixlen || (apiHasMape ? api.ipv4PrefixLength : ''),
        v6p: userConfig.mapeIpv6Prefix || (apiHasMape ? api.ipv6Prefix : ''),
        v6l: userConfig.mapeIpv6Prefixlen || (apiHasMape ? api.ipv6PrefixLength : ''),
        off: userConfig.mapePsidOffset || (apiHasMape ? api.psIdOffset : ''),
        psid: userConfig.mapePsidlen || (apiHasMape ? api.psidlen : '')
    };

    // GUA„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ
    const guaPrefix = userConfig.mapeGuaPrefix || calculateGuaPrefixFromApi() || '';

    // ÈÅ∏Êäû„Éó„É≠„Éà„Ç≥„É´
    const manual = (userConfig.connectionMode === 'manual');
    let activeProto = '';

    if (manual) {
        activeProto = userConfig.connectionType;
    } else {
        if (apiHasDslite) activeProto = 'dslite';
        else if (apiHasMape) activeProto = 'mape';
        else activeProto = 'dhcp';
    }

    // APÂà§ÂÆöÔºàÈáçË¶ÅÔºövariablesÂÆöÁæ©„Çà„ÇäÂâç„Å´Ë°å„ÅÜÔºâ
    const apActive = (activeProto === 'ap');
    
    // Wi-FiË®≠ÂÆöÂà§ÂÆö
    const wifiActive = !!(userConfig.wifiSSID && userConfig.wifiPassword && String(userConfig.wifiPassword).length >= 8);
    
    // „Éó„É≠„Éà„Ç≥„É´Âà•„ÅÆÂà§ÂÆö
    const pppoeActive = (activeProto === 'pppoe');
    const mapeActive = (activeProto === 'mape');
    const guaActive = mapeActive && (userConfig.mapeType === 'gua' || userConfig.mapeType === 'auto');
    
    // DS-LiteË®≠ÂÆö
    let dsliteAddress = '';
    if (userConfig.dsliteMode === 'auto') {
        dsliteAddress = (apiInfo?.mape?.aftrIpv6Address) || userConfig.dsliteAftrAddress || '';
    } else {
        dsliteAddress = userConfig.dsliteAftrAddress || '';
    }
    const dsliteActive = (activeProto === 'dslite') && !!dsliteAddress;

    // Â§âÊï∞ÂÆöÁæ©„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊßãÁØâ
    const variables = {
        // Basic settings
        device_name: { value: userConfig.deviceName, active: !!userConfig.deviceName },
        root_password: { value: userConfig.rootPassword, active: !!userConfig.rootPassword },
        language: { value: userConfig.language, active: !!userConfig.language },
        country: { value: userConfig.country, active: !!userConfig.country },
        timezone: { value: userConfig.timezone, active: !!userConfig.timezone },
        zonename: { value: userConfig.zonename, active: !!userConfig.zonename },
        
        // Network settingsÔºàAPÂà§ÂÆöÂæå„Å´Ë®≠ÂÆöÔºâ
        lan_ip_address: { value: userConfig.lanIpv4, active: !!userConfig.lanIpv4 && !apActive },
        lan_ipv6_address: { value: userConfig.lanIpv6, active: !!userConfig.lanIpv6 && !apActive },
        
        // Wi-Fi
        wlan_name: { value: userConfig.wifiSSID, active: wifiActive },
        wlan_password: { value: userConfig.wifiPassword, active: wifiActive },
        
        // SSH
        ssh_interface: { value: userConfig.sshInterface, active: !!userConfig.sshInterface },
        ssh_port: { value: userConfig.sshPort, active: !!userConfig.sshPort },
        
        // System
        flow_offloading_type: { value: userConfig.flowOffloading, active: !!userConfig.flowOffloading },
        backup_path: { value: userConfig.backupPath, active: !!userConfig.backupPath },

        // PPPoE
        pppoe_username: { value: userConfig.pppoeUsername || '', active: pppoeActive },
        pppoe_password: { value: userConfig.pppoePassword || '', active: pppoeActive },

        // DS-Lite
        dslite_aftr_address: { value: dsliteAddress, active: dsliteActive },

        // MAP-E
        mape_br: { value: mapeVals.br || '', active: mapeActive },
        mape_ealen: { value: mapeVals.ealen || '', active: mapeActive },
        mape_ipv4_prefix: { value: mapeVals.v4p || '', active: mapeActive },
        mape_ipv4_prefixlen: { value: mapeVals.v4l || '', active: mapeActive },
        mape_ipv6_prefix: { value: mapeVals.v6p || '', active: mapeActive },
        mape_ipv6_prefixlen: { value: mapeVals.v6l || '', active: mapeActive },
        mape_psid_offset: { value: mapeVals.off || '', active: mapeActive },
        mape_psidlen: { value: mapeVals.psid || '', active: mapeActive },
        mape_gua_mode: { value: guaActive ? '1' : '', active: guaActive },
        mape_gua_prefix: { value: guaActive ? guaPrefix : '', active: guaActive },

        // AP
        ap_ip_address: { value: userConfig.apIpAddress, active: apActive && !!userConfig.apIpAddress },
        ap_gateway: { value: userConfig.apGateway, active: apActive && !!userConfig.apGateway }
    };

    // enable_* „Éï„É©„Ç∞ÔºàÈÅ∏Êäû„Åß ON„ÄÅÈùûÈÅ∏Êäû„ÅØË®≠ÂÆö„Åó„Å™„ÅÑÔºâ
    if (selectedPackages) {
        const enableMap = {};
        
        PACKAGE_DB.categories.forEach(cat => {
            (cat.packages || []).forEach(pkg => {
                if (pkg.enableVar) {
                    enableMap[pkg.name] = pkg.enableVar;
                }
            });
        });

        // ÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Çã„Éë„ÉÉ„Ç±„Éº„Ç∏„Å´ÂØæÂøú„Åô„Çã enableVar „ÇíË®≠ÂÆö
        selectedPackages.forEach(pkgName => {
            const varName = enableMap[pkgName];
            if (varName) {
                variables[varName] = { value: '1', active: true };
            }
        });
    }

    // Â§âÊï∞ÂÆöÁæ©„ÇíÈÅ©Áî®
    customized = setVariableDefinitions(customized, variables);

    // Custom Commands
    const customCommands = getCustomCommands();
    
    const managedRegion = /(# BEGIN_CUSTOM_COMMANDS\n)([\s\S]*?)(# END_CUSTOM_COMMANDS\n)/;
    
    if (customCommands.length > 0) {
        const commandsText = customCommands.join('\n');
        customized = customized.replace(managedRegion, `$1${commandsText}\n$3`);
    } else {
        customized = customized.replace(managedRegion, `$1$3`);
    }
    
    return customized;
}
        
function getCustomCommands() {
    const commands = [];
    // „É°„Ç§„É≥ÂÖ•ÂäõÊ¨Ñ
    const mainCommand = document.getElementById('command');
    if (mainCommand) {
        const val = mainCommand.value != null ? mainCommand.value.trim() : '';
        if (val.length > 0) {
            commands.push(val);
        }
    }
    // ËøΩÂä†„Ç≥„Éû„É≥„ÉâÊ¨ÑÔºàÁ©∫Ê¨Ñ‰ª•Â§ñ„Çí„Åô„Åπ„Å¶ÂèçÊò†Ôºâ
    const extraInputs = document.querySelectorAll('#commands-autocomplete input.command');
    extraInputs.forEach((el) => {
        if (!el) return;
        const val = el.value != null ? el.value.trim() : '';
        if (val.length > 0) {
            commands.push(val);
        }
    });
    // ÈáçË§áÈô§ÂéªÔºàÈ†ÜÂ∫è„ÅØ‰øùÊåÅÔºâ
    const seen = new Set();
    const uniqueCommands = commands.filter(cmd => {
        if (seen.has(cmd)) return false;
        seen.add(cmd);
        return true;
    });
    return uniqueCommands;
}

function toggleAiosConfig(e) {
    const details = document.getElementById('use-aios-config-details');
    if (details && details.open) {
        updateConfiguredTemplate();
    } else {
        document.getElementById('uci-defaults-content').value = SETUP_SH_TEMPLATE;
        app.templateLoaded = true;
    }
}

function getAiosConfig() {
    const parseOrEmpty = (id, type = 'string') => {
        const element = document.getElementById(id);
        if (!element) return '';
        
        // value „ÅåÁ©∫„Åß„ÇÇ„ÄÅHTML „ÅÆÂàùÊúüÂÄ§Ôºàplaceholder „ÇÑ value Â±ûÊÄßÔºâ„ÇíÁ¢∫Ë™ç
        let val = element.value?.trim();
        if (!val && element.getAttribute('value')) {
            val = element.getAttribute('value').trim();
        }
        if (!val) return '';
        
        if (type === 'int') {
            const num = parseInt(val, 10);
            return isNaN(num) ? '' : num;
        }
        return val;
    };

    const config = {
        language: parseOrEmpty('aios-language'),
        country: parseOrEmpty('aios-country'),
        timezone: parseOrEmpty('aios-timezone'),
        zonename: parseOrEmpty('aios-zonename'),
        deviceName: parseOrEmpty('aios-device-name'),
        lanIpv4: parseOrEmpty('aios-lan-ipv4'),
        lanIpv6: parseOrEmpty('aios-lan-ipv6'),
        rootPassword: parseOrEmpty('aios-root-password'),
        wifiSSID: parseOrEmpty('aios-wifi-ssid'),
        wifiPassword: parseOrEmpty('aios-wifi-password'),
        apIpAddress: parseOrEmpty('ap-ip-address'),
        apGateway: parseOrEmpty('ap-gateway'),
        sshInterface: parseOrEmpty('aios-ssh-interface'),
        sshPort: parseOrEmpty('aios-ssh-port', 'int'),
        flowOffloading: parseOrEmpty('aios-flow-offloading'),
        backupPath: parseOrEmpty('aios-backup-path'),
        
        connectionMode: document.querySelector('input[name="connectionMode"]:checked')?.value || 'auto',
        connectionType: document.querySelector('input[name="connectionType"]:checked')?.value || 'dhcp',
        mapeType: document.querySelector('input[name="mapeType"]:checked')?.value || 'auto',

        pppoeUsername: parseOrEmpty('pppoe-username'),
        pppoePassword: parseOrEmpty('pppoe-password'),

        dsliteAftrAddress: parseOrEmpty('dslite-aftr-address'),
        dsliteMode: document.querySelector('input[name="dsliteMode"]:checked')?.value || 'auto',
        dsliteAftrType: parseOrEmpty('dslite-aftr-type'),
        dsliteArea: parseOrEmpty('dslite-area'),
        
        mapeBr: parseOrEmpty('mape-br'),
        mapeEalen: parseOrEmpty('mape-ealen', 'int'),
        mapeIpv4Prefix: parseOrEmpty('mape-ipv4-prefix'),
        mapeIpv4Prefixlen: parseOrEmpty('mape-ipv4-prefixlen', 'int'),
        mapeIpv6Prefix: parseOrEmpty('mape-ipv6-prefix'),
        mapeIpv6Prefixlen: parseOrEmpty('mape-ipv6-prefixlen', 'int'),
        mapePsidOffset: parseOrEmpty('mape-psid-offset', 'int'),
        mapePsidlen: parseOrEmpty('mape-psidlen', 'int'),
        mapeGuaPrefix: parseOrEmpty('mape-gua-prefix')
    };

    return config;
}

function applyInitialsFromApi(type) {
    if (type === 'dslite') {
        const aftrInput = document.getElementById('dslite-aftr-address');
        const dsliteMode = document.querySelector('input[name="dsliteMode"]:checked')?.value || 'auto';
        
        if (dsliteMode === 'auto') {
            // APIÊ§úÂá∫ÂÄ§„Çí‰ΩøÁî®
            if (window.cachedApiInfo && window.cachedApiInfo.mape && window.cachedApiInfo.mape.aftrIpv6Address) {
                if (aftrInput) {
                    aftrInput.value = window.cachedApiInfo.mape.aftrIpv6Address;
                }
            }
        } else {
            // Manual mode: Âú∞Âüü„Éª„Çø„Ç§„Éó„Éô„Éº„Çπ„ÅÆË®≠ÂÆö
            const areaSel = document.getElementById('dslite-area');
            const typeSel = document.getElementById('dslite-aftr-type');

            const area = areaSel?.value || 'east';
            const aftrType = typeSel?.value || 'transix';

            const aftrMap = {
                transix: {
                    east: '2404:8e00::feed:100',
                    west: '2404:8e01::feed:100'
                },
                xpass: {
                    east: '2001:f60:0:200::1:1',
                    west: '2001:f60:0:200::1:1'
                },
                v6option: {
                    east: '2404:8e00::feed:101',
                    west: '2404:8e01::feed:101'
                }
            };

            if (aftrInput) {
                const regionKey = area === 'west' ? 'west' : 'east';
                aftrInput.value = aftrMap[aftrType]?.[regionKey] || '';
            }
        }
    }

    // MAP-E: API„ÅÆÂàùÊúüÂÄ§„Çí„Åù„ÅÆ„Åæ„ÅæÊµÅ„ÅóËæº„ÇÄÔºàÂàùÊúüÂåñ„ÅØÁÑ°Êù°‰ª∂„Å´‰∏äÊõ∏„ÅçÔºâ
    if (type === 'mape') {
        const s = (window.cachedApiInfo && window.cachedApiInfo.mape) ? window.cachedApiInfo.mape : null;

        // Êó¢Áü•„ÅÆ„Ç≠„Éº„ÅåÁÑ°„ÅÑÂ†¥Âêà„Åß„ÇÇÁÑ°Êù°‰ª∂ÂàùÊúüÂåñ„ÅÆ„Éù„É™„Ç∑„Éº„Å´Âæì„ÅÑ„ÄÅÂÄ§„Åå„ÅÇ„Çã„ÇÇ„ÅÆ„ÅØ‰∏äÊõ∏„Åç
        const set = (id, val) => {
            const el = document.getElementById(id);
            if (!el) return;
            if (val !== undefined && val !== null) el.value = val;
        };

        if (s) {
            set('mape-br', s.brIpv6Address);
            set('mape-ealen', s.eaBitLength);
            set('mape-ipv4-prefix', s.ipv4Prefix);
            set('mape-ipv4-prefixlen', s.ipv4PrefixLength);
            set('mape-ipv6-prefix', s.ipv6Prefix);
            set('mape-ipv6-prefixlen', s.ipv6PrefixLength);
            set('mape-psid-offset', s.psIdOffset);
            set('mape-psidlen', s.psidlen);
        }
        
        // GUA„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇÇË®≠ÂÆö
        const guaPrefix = calculateGuaPrefixFromApi();
        if (guaPrefix) {
            set('mape-gua-prefix', guaPrefix);
        }
        
        // GUA„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
        updateGuaSectionVisibility();
    }
}

// === Êñ∞Ë¶èËøΩÂä†ÔºöÂÖ®ÂÖ•ÂäõÁµåË∑Ø„ÇíÂèéÊùü„Åï„Åõ„ÇãÁµÇÁÇπ„É≠„Ç∏„ÉÉ„ÇØ ===
function syncTemplateAndPackages(opts = {}) {
    const textarea = document.getElementById('asu-packages');
    let pkgList = split(textarea.value);

    // Â§ñÈÉ®„Åã„Çâ„ÅÆÊõ¥Êñ∞ÂàÜ„Çí„Éû„Éº„Ç∏
    if (Array.isArray(opts.updatedPackages)) {
        pkgList = mergeUnique(pkgList, opts.updatedPackages);
    }
    textarea.value = pkgList.join(' ');

    // ÂøÖÈ†à„Éë„ÉÉ„Ç±„Éº„Ç∏ËøΩÂä† + i18nÊï¥ÁêÜ
    updateRequiredPackages();
    asuCollectPackages();

    // „ÉÜ„É≥„Éó„É¨„ÅØGUIÈñãÁä∂ÊÖã„ÅÆ„ÅøÂÜçÁîüÊàê
    if (document.getElementById('use-aios-config-details').open) {
        updateConfiguredTemplate();
    }
}

function mergeUnique(base, extra) {
    const set = new Set(base);
    (extra || []).forEach(p => set.add(p));
    return Array.from(set);
}
        
function refreshTemplateAndPackages() {
    // „Çª„É¨„ÇØ„Çø„Éº„ÅÆÂàùÊúüÂÄ§„ÇíÂèçÊò†Ôºà„Éê„Ç∞‰øÆÊ≠£Ôºâ
    const checkedPackages = [];
    document.querySelectorAll('.package-selector-checkbox:checked').forEach(cb => {
        const pkgName = cb.getAttribute('data-package');
        if (pkgName) checkedPackages.push(pkgName);
    });
    
    if (checkedPackages.length > 0) {
        const textarea = document.getElementById('asu-packages');
        const currentList = split(textarea.value);
        const mergedList = Array.from(new Set([...currentList, ...checkedPackages]));
        textarea.value = mergedList.join(' ');
    }
    
    // ÂøÖË¶Å„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆÊõ¥Êñ∞Ôºàmap, ds-liteÁ≠âÔºâ
    updateRequiredPackages();
    
    // i18n Êï¥ÁêÜ
    asuCollectPackages();

    // aios-config ÊúâÂäπÊôÇ„ÅÆ„Åø„ÉÜ„É≥„Éó„É¨Êõ¥Êñ∞
    if (document.getElementById('use-aios-config-details').open) {
        updateConfiguredTemplate();
    }
}

// ==================== „Éë„ÉÉ„Ç±„Éº„Ç∏ÁÆ°ÁêÜ ====================
function split(str) {
    return str.match(/[^\s,]+/g) || [];
}

function updateRequiredPackages() {
  const config = getAiosConfig();
  const packagesTextarea = document.getElementById('asu-packages');
  let currentPackages = split(packagesTextarea.value);

  // Ëá™ÂãïËøΩÂä†ÂØæË±°„ÇíÂà∂ÈôêÔºàmap, ds-lite „ÅÆ„ÅøÔºâ
  currentPackages = currentPackages.filter(pkg =>
    pkg !== 'map' &&
    pkg !== 'ds-lite'
  );
    
  // Êé•Á∂öÊñπÂºè„Å´Âøú„Åò„Åü„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆËøΩÂä†
  if (config.connectionMode === 'auto') {
    if (window.cachedApiInfo && window.cachedApiInfo.mape) {
        if (window.cachedApiInfo.mape.aftrType) {
            if (!currentPackages.includes('ds-lite')) {
                currentPackages.push('ds-lite');
            }
        } else if (window.cachedApiInfo.mape.brIpv6Address) {
            if (!currentPackages.includes('map')) {
                currentPackages.push('map');
            }
        }
    }

  } else {
      switch(config.connectionType) {
          case 'mape':
              if (!currentPackages.includes('map')) {
                  currentPackages.push('map');
              }
              break;
          case 'dslite':
              if (!currentPackages.includes('ds-lite')) {
                  currentPackages.push('ds-lite');
              }
              break;
      }
  }

  // ÊúÄÁµÇÈáçË§áÊéíÈô§ÔºàÊâãÂÖ•ÂäõÈáçË§á„Å™„Å©„Å´„ÇÇÂº∑„Åè„Åô„ÇãÔºâ
  currentPackages = Array.from(new Set(currentPackages));
    
  packagesTextarea.value = currentPackages.join(' ');
}

// ==================== „Éì„É´„Éâ„Ç®„É©„ÉºÂá¶ÁêÜÁµ±‰∏Ä ====================
const BuildErrorHandler = {
    // „Çπ„ÇØ„É™„Éó„Éà„Çµ„Ç§„Ç∫Ë®àÁÆóÔºà„Ç∑„Çπ„ÉÜ„É†‰ΩøÁî®ÂàÜ„ÇÇÂê´„ÇÄÔºâ
    calculateTotalSize(script, packages) {
        const scriptSize = new Blob([script]).size;
        const packagesSize = new Blob([packages.join(' ')]).size;
        const systemOverhead = 1024; // „Ç∑„Çπ„ÉÜ„É†‰ΩøÁî®ÂàÜÁ¥Ñ1KB
        const totalSize = scriptSize + packagesSize + systemOverhead;
        
        console.log(`[SIZE CHECK] Script: ${scriptSize}B, Packages: ${packagesSize}B, System: ${systemOverhead}B, Total: ${totalSize}B`);
        
        return {
            scriptSize,
            packagesSize,
            systemOverhead,
            totalSize,
            isOverLimit: totalSize > 20480 // 20KB = 20480 bytes
        };
    },

    // „Ç®„É©„ÉºË°®Á§∫Áµ±‰∏ÄÂá¶ÁêÜ
    showError(errorType, statusCode, errorData, sizeInfo = null) {
        // ÈÄ≤Êçó„Éê„Éº„ÇíËµ§„ÅÑ„Ç®„É©„ÉºË°®Á§∫„Å´Â§âÊõ¥
        this.showErrorProgress(errorType, statusCode);
        
        // „Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫
        hideProgress();
        showBuildStatus(`Build failed: ${errorType}`, 'error');
        
        // Ë©≥Á¥∞„Ç®„É©„ÉºÊÉÖÂ†±„ÇíÊßãÁØâ
        const errorDetails = this.buildErrorDetails(errorType, statusCode, errorData, sizeInfo);
        
        // „Ç®„É©„ÉºË©≥Á¥∞„Çídownload-links„Å´Ë°®Á§∫
        const container = document.getElementById('download-links');
        container.innerHTML = errorDetails;
        
        // „Ç®„É©„Éº„Ç®„É™„Ç¢„Å´„Çπ„ÇØ„É≠„Éº„É´
        setTimeout(() => {
            container.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
        }, 200);
    },

    // ÈÄ≤Êçó„Éê„Éº„ÅÆ„Ç®„É©„ÉºË°®Á§∫
    showErrorProgress(errorType, statusCode) {
        const progressElement = document.getElementById('build-progress');
        const messageElement = document.getElementById('build-message');
        const progressBar = document.getElementById('progress-bar');
        
        // ÈÄ≤Êçó„Éê„Éº„ÇíËµ§„Å´Â§âÊõ¥
        progressBar.style.backgroundColor = '#dc3545';
        progressBar.style.width = '100%';
        messageElement.textContent = `Build failed: ${errorType} (HTTP ${statusCode})`;
        progressElement.style.display = 'block';
        
        // 5ÁßíÂæå„Å´Ëá™Âãï„ÅßÈö†„Åô
        setTimeout(() => {
            hideProgress();
        }, 5000);
    },

    // „Ç®„É©„ÉºË©≥Á¥∞HTMLÊßãÁØâ
    buildErrorDetails(errorType, statusCode, errorData, sizeInfo) {
        let html = `
            <div class="asu-error" style="margin-top: 1rem;">
                <h4>Build Failed - ${errorType}</h4>
                <div><strong>HTTP Status:</strong> ${statusCode}</div>
        `;

        // 20KBÂà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        if (sizeInfo && sizeInfo.isOverLimit) {
            html += `
                <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 1rem; margin: 1rem 0; border-radius: 0.25rem;">
                    <h5 style="margin-top: 0; color: #721c24;">üö´ Size Limit Exceeded</h5>
                    <div><strong>Total Size:</strong> ${sizeInfo.totalSize} bytes (Limit: 20,480 bytes)</div>
                    <div><strong>Breakdown:</strong></div>
                    <ul style="margin: 0.5rem 0;">
                        <li>Script: ${sizeInfo.scriptSize} bytes</li>
                        <li>Packages: ${sizeInfo.packagesSize} bytes</li>
                        <li>System overhead: ${sizeInfo.systemOverhead} bytes</li>
                    </ul>
                    <div><strong>Over by:</strong> ${sizeInfo.totalSize - 20480} bytes</div>
                </div>
            `;
        }

        // „Ç®„É©„ÉºË©≥Á¥∞
        if (errorData) {
            if (typeof errorData === 'string') {
                html += `<div><strong>Error Details:</strong></div>
                         <pre style="background: #f8f8f8; padding: 10px; margin: 10px 0; border-radius: 4px; overflow-x: auto; font-size: 0.9em; max-height: 200px;">${errorData}</pre>`;
            } else if (typeof errorData === 'object') {
                // „É™„ÇØ„Ç®„Çπ„Éà„Éè„ÉÉ„Ç∑„É•„Åå„ÅÇ„Çå„Å∞Ë°®Á§∫
                if (errorData.request_hash) {
                    html += `<div><strong>Request ID:</strong> <code>${errorData.request_hash}</code></div>`;
                }
                
                // „Åù„ÅÆ‰ªñ„ÅÆË©≥Á¥∞ÊÉÖÂ†±
                const excludeFields = ['request_hash'];
                for (const [key, value] of Object.entries(errorData)) {
                    if (!excludeFields.includes(key) && value != null) {
                        html += `<div><strong>${key}:</strong> ${JSON.stringify(value)}</div>`;
                    }
                }
            }
        }

        // „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞ÊÉÖÂ†±
        html += this.getTroubleshootingInfo(errorType, sizeInfo);
        html += '</div>';
        
        return html;
    },

    // „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞ÊÉÖÂ†±
    getTroubleshootingInfo(errorType, sizeInfo) {
        let tips = [];
        
        if (sizeInfo && sizeInfo.isOverLimit) {
            tips.push('Remove unnecessary packages or custom commands to reduce size');
            tips.push('Consider using minimal package selection');
        }
        
        if (errorType.includes('500')) {
            tips.push('Verify network connectivity and try again');
            tips.push('Check if custom script syntax is correct');
            tips.push('Try building without custom packages first');
        }
        
        if (tips.length === 0) {
            tips.push('Verify device selection and network connectivity');
            tips.push('Try again with reduced package selection');
        }

        return `
            <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 1rem; margin: 1rem 0; border-radius: 0.25rem;">
                <h5 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Troubleshooting</h5>
                <ul style="margin-bottom: 0;">
                    ${tips.map(tip => `<li>${tip}</li>`).join('')}
                </ul>
            </div>
        `;
    }
};
        
// ==================== „Éì„É´„ÉâÂá¶ÁêÜ ====================
async function buildAsuRequest() {
    console.log('[buildAsuRequest] Function entered');
    
    if (!current_device || !current_device.id) {
        console.log('[buildAsuRequest] No device selected');
        alert('Please select a device first');
        return;
    }
    
    console.log('[buildAsuRequest] Device check passed');

    try {
        console.log('[buildAsuRequest] Entering try block');
        document.getElementById('request-build').disabled = true;
        console.log('[buildAsuRequest] Button disabled');
        showProgress('Preparing build request...', 10);
        console.log('[buildAsuRequest] Progress shown');
        
        // ÂàùÂõû„ÅÆÈÄ≤ÊçóË°®Á§∫ÊôÇ„Å´Á¢∫ÂÆü„Å´„Çπ„ÇØ„É≠„Éº„É´
        setTimeout(() => {
            const progressElement = document.getElementById('build-progress');
            if (progressElement) {
                progressElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }
        }, 200);

        console.log('[buildAsuRequest] Getting packages');
        const packages = split(document.getElementById('asu-packages').value);
        console.log('[buildAsuRequest] Getting script');
        let script = document.getElementById('uci-defaults-content').value;
        const originalSize = script.length;
        console.log('[buildAsuRequest] Calling MapEProcessor');
        // MAP-EÂá¶ÁêÜÔºàÂøÖË¶ÅÊôÇ„ÅÆ„Åø„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºÁΩÆÊèõÔºâ
        script = await MapEProcessor.processForBuild(
            script, 
            getAiosConfig(), 
            window.cachedApiInfo
        );
        console.log('[VERIFY] Script size:', originalSize, '‚Üí', script.length, '(', script.length - originalSize, 'bytes added)');
        console.log('[buildAsuRequest] MapEProcessor completed');

        console.log('[buildAsuRequest] Building request body');
        const requestBody = {
            target: current_device.target,
            profile: current_device.id,
            packages: packages,
            version: app.selectedVersion
        };

        console.log('[buildAsuRequest] About to send fetch request');

        if (script && script.trim()) {
            requestBody.defaults = script;
        }

        // „Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØ„Çí‰∫ãÂâçÂÆüË°å
        const sizeInfo = BuildErrorHandler.calculateTotalSize(script, packages);
        
        fetch('https://sysupgrade.openwrt.org/api/v1/build', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestBody)
        })
        .then((response) => {
            switch (response.status) {
                case 200:
                    showProgress('Build completed!', 100);
                    response.json().then((mobj) => {
                        if ('stderr' in mobj) {
                            document.getElementById('asu-stderr').innerText = mobj.stderr;
                            document.getElementById('asu-stdout').innerText = mobj.stdout;
                            document.getElementById('asu-log').style.display = 'block';
                        } else {
                            document.getElementById('asu-log').style.display = 'none';
                        }
                        hideProgress();
                        showBuildStatus('Build successful', 'info');
                        mobj['id'] = current_device.id;
                        showDownloadLinks(mobj.images || [], mobj, mobj.request_hash);
                    });
                    break;
                case 202:
                    response.json().then((mobj) => {
                        showProgress(`${mobj.imagebuilder_status || 'Processing'}...`, 30);
                        setTimeout(() => pollBuildStatus(mobj.request_hash), 5000);
                    });
                    break;
                case 400: // bad request
                case 422: // bad package
                case 500: // build failed
                    response.text().then((responseText) => {
                        hideProgress();
                        showBuildStatus('Build failed: HTTP 500 Server Error', 'error');
                        
                        // Ë©≥Á¥∞„Å™„Ç®„É©„ÉºÊÉÖÂ†±„ÇíË°®Á§∫
                        const container = document.getElementById('download-links');
                        container.innerHTML = `
                            <div class="asu-error" style="margin-top: 1rem;">
                                <h4>Build Failed - Server Error</h4>
                                <div><strong>HTTP Status:</strong> 500 Internal Server Error</div>
                                <div><strong>Error Details:</strong></div>
                                <pre style="background: #f8f8f8; padding: 10px; margin: 10px 0; border-radius: 4px; overflow-x: auto; font-size: 0.9em; max-height: 200px;">${responseText}</pre>
                            </div>
                            
                            <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 1rem; margin: 1rem 0; border-radius: 0.25rem;">
                                <h5 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Troubleshooting</h5>
                                <p style="margin-bottom: 0;">Please verify network connectivity, package selection, and script configuration. Try removing custom packages or scripts, then retry the build.</p>
                            </div>
                        `;
                    });
                    break;
            }
        })
        .catch((err) => {
            BuildErrorHandler.showError('Network Error', null, err.message, sizeInfo);
        });

    } catch (error) {
        console.error('Build request failed:', error);
        hideProgress();
        showBuildStatus(`Build failed: ${error.message}`, 'error');
    } finally {
        document.getElementById('request-build').disabled = false;
    }
}

async function pollBuildStatus(requestHash) {
    const maxAttempts = 120;
    let attempts = 0;
    const startTime = Date.now();

    while (attempts < maxAttempts) {
        try {
            const statusUrl = `https://sysupgrade.openwrt.org/api/v1/build/${requestHash}`;
            const response = await fetch(statusUrl, {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });

            if (!response.ok) {
                if (response.status === 404 && attempts < 5) {
                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

                    showProgress(`Waiting for build to start... ${timeStr}`, 10);
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    attempts++;
                    continue;
                }
                throw new Error(`Status check failed: HTTP ${response.status}`);
            }

            const statusText = await response.text();
            let status;

            try {
                status = JSON.parse(statusText);
            } catch (e) {
                throw new Error('Invalid JSON in status response: ' + statusText);
            }

            const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

            const progressPercent = Math.min((elapsedSeconds / 600) * 85 + 10, 95);
            const progressMsg =
                status.detail && typeof status.detail === 'string' ? status.detail :
                status.status && typeof status.status === 'string' ? status.status :
                'Processing';

            if (status.status === 'done' || status.status === 'success' || 
                status.detail === 'done' || status.imagebuilder_status === 'done') {
                const images = status.images || 
                               status.request?.images || 
                               status.request?.files ||
                               status.files || [];

                const rh = status.request_hash || status.request?.request_hash;

                showProgress('Build completed!', 100);
                setTimeout(() => {
                    hideProgress();
                    showBuildStatus('Build successful', 'info');
                    
                    // STDERR/STDOUT „ÅÆË°®Á§∫
                    if (status.stderr || status.stdout) {
                        document.getElementById('asu-stderr').textContent = status.stderr || 'No errors';
                        document.getElementById('asu-stdout').textContent = status.stdout || 'No output';
                        document.getElementById('asu-log').style.display = 'block';
                    }
                    
                    showDownloadLinks(images, status, rh);
                }, 500);
                return;
            }

            if (status.status === 'failed' || status.status === 'failure' || 
                status.detail === 'failed' || status.imagebuilder_status === 'failed') {
                
                // „Éì„É´„ÉâÂ§±ÊïóÊôÇ„ÇÇË©≥Á¥∞ÊÉÖÂ†±„ÇíË°®Á§∫
                hideProgress();
                showBuildError(status, null);
                return;
            }

            showProgress(`${progressMsg}... ${timeStr}`, progressPercent);
            await new Promise(resolve => setTimeout(resolve, 5000));
            attempts++;

        } catch (error) {
            if (attempts >= 5) throw error;

            const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            showProgress(`Connection error, retrying... ${elapsedSeconds}s`, 5);
            await new Promise(resolve => setTimeout(resolve, 5000));
            attempts++;
        }
    }

    throw new Error('Build timeout after 10 minutes');
}

function showProgress(message, percentage) {
    document.getElementById('build-message').textContent = message;
    document.getElementById('progress-bar').style.width = `${percentage}%`;
    document.getElementById('build-progress').style.display = 'block';
    
    // ÈÄ≤Êçó„Éê„Éº„Ç®„É™„Ç¢„Å´„Çπ„ÇØ„É≠„Éº„É´„Åó„Å¶ÂøÖ„ÅöË¶ã„Åà„Çã„Çà„ÅÜ„Å´„Åô„Çã
    setTimeout(() => {
        const progressElement = document.getElementById('build-progress');
        if (progressElement) {
            progressElement.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'nearest',
                inline: 'nearest'
            });
        }
    }, 100); // DOMÊõ¥Êñ∞Âæå„Å´„Çπ„ÇØ„É≠„Éº„É´
}

function hideProgress() {
    document.getElementById('build-progress').style.display = 'none';
}

function showBuildStatus(message, type) {
    const bs = document.getElementById('asu-buildstatus');
    
    if (type === 'error') {
        bs.classList.remove('asu-info');
        bs.classList.add('asu-error');
    } else {
        bs.classList.remove('asu-error');
        bs.classList.add('asu-info');
    }
    
    bs.querySelector('span').textContent = message;
    bs.style.display = 'block';
}

function formatDate(date) {
    if (!date) return '';
    const d = new Date(date);
    return d.toLocaleString();
}

function showDownloadLinks(images, fullStatus, requestHash) {
    const container = document.getElementById('download-links');
    
    if (!images || images.length === 0) {
        container.innerHTML = '<h4>Downloads</h4><p>No images available</p>';
        return;
    }
    
    container.innerHTML = `
        <div class="images">
            <h4>Factory Image</h4>
            <p class="text-muted">The factory image is used for the initial flashing of OpenWrt. This would replace an existing firmware.</p>
            <div id="factory-images"></div>
            
            <h4>Sysupgrade Image</h4>
            <p class="text-muted">The sysupgrade image is used to upgrade an existing OpenWrt installation.</p>
            <div id="sysupgrade-images"></div>
            
            <div id="other-images" style="display: none;">
                <h4>Other Images</h4>
                <div id="other-images-content"></div>
            </div>
        </div>
    `;

    const factoryContainer = document.getElementById('factory-images');
    const sysupgradeContainer = document.getElementById('sysupgrade-images');
    const otherContainer = document.getElementById('other-images-content');
    const otherSection = document.getElementById('other-images');
    
    let hasFactory = false;
    let hasSysupgrade = false;
    let hasOther = false;

    images.forEach((image) => {
        if (!image.name || !requestHash) return;
        
        const imageUrl = `https://sysupgrade.openwrt.org/store/${requestHash}/${image.name}`;
        const fileName = image.name;
        
        const link = document.createElement('a');
        link.href = imageUrl;
        link.className = 'download-link';
        link.target = '_blank';
        link.download = fileName;
        link.title = fileName;
        
        // ÂÖ¨Âºè„Å´Âêà„Çè„Åõ„Åü„Éï„Ç°„Ç§„É´Âêç„ÅÆË°®Á§∫ÂΩ¢Âºè
        let displayName = fileName;
        
        // „Éï„Ç°„Ç§„É´„Çø„Ç§„Éó„ÅÆÂà§ÂÆö„Å®ÊåØ„ÇäÂàÜ„Åë
        if (image.type) {
            const type = image.type.toLowerCase();
            
            if (type.includes('factory')) {
                displayName = fileName;
                link.textContent = displayName;
                factoryContainer.appendChild(link);
                factoryContainer.appendChild(document.createTextNode(' '));
                hasFactory = true;
            } else if (type.includes('sysupgrade')) {
                displayName = fileName;
                link.textContent = displayName;
                sysupgradeContainer.appendChild(link);
                sysupgradeContainer.appendChild(document.createTextNode(' '));
                hasSysupgrade = true;
            } else {
                displayName = fileName;
                link.textContent = displayName;
                otherContainer.appendChild(link);
                otherContainer.appendChild(document.createTextNode(' '));
                hasOther = true;
            }
        } else {
            // type„Åå‰∏çÊòé„Å™Â†¥Âêà„ÅØ„Éï„Ç°„Ç§„É´Âêç„ÅßÂà§ÂÆö
            const nameLower = fileName.toLowerCase();
            if (nameLower.includes('factory')) {
                link.textContent = displayName;
                factoryContainer.appendChild(link);
                factoryContainer.appendChild(document.createTextNode(' '));
                hasFactory = true;
            } else if (nameLower.includes('sysupgrade')) {
                link.textContent = displayName;
                sysupgradeContainer.appendChild(link);
                sysupgradeContainer.appendChild(document.createTextNode(' '));
                hasSysupgrade = true;
            } else {
                link.textContent = displayName;
                otherContainer.appendChild(link);
                otherContainer.appendChild(document.createTextNode(' '));
                hasOther = true;
            }
        }
    });
    
    // Á©∫„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„Å´„ÄåÂà©Áî®‰∏çÂèØ„Äç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
    if (!hasFactory) {
        factoryContainer.innerHTML = '<span class="text-muted">No factory image available for this device.</span>';
    }
    
    if (!hasSysupgrade) {
        sysupgradeContainer.innerHTML = '<span class="text-muted">No sysupgrade image available for this device.</span>';
    }
    
    // „Åù„ÅÆ‰ªñ„ÅÆ„Ç§„É°„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø„Çª„ÇØ„Ç∑„Éß„É≥„ÇíË°®Á§∫
    if (hasOther) {
        otherSection.style.display = 'block';
    }
    
    // BuildÊÉÖÂ†±„ÇíË°®Á§∫ÔºàÂÖ¨Âºè„Çπ„Çø„Ç§„É´Ôºâ
    if (requestHash) {
        const buildInfo = document.createElement('div');
        buildInfo.className = 'info';
        buildInfo.style.marginTop = '1rem';
        buildInfo.innerHTML = `
            <h5>Build Information</h5>
            <div>Request ID: <code>${requestHash}</code></div>
            <div>Build completed successfully</div>
        `;
        container.appendChild(buildInfo);
    }
}

// ‚òÖ„Éë„ÉÉ„Ç±„Éº„Ç∏„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÂèñÂæóÔºàSNAPSHOT/Release ÂÖ±ÈÄöÔºâ
async function fetchDevicePackages() {
    app.devicePackages = [];
    if (!current_device || !current_device.id || !app.selectedVersion) return;

    const version     = app.selectedVersion;
    const targetPath  = current_device.target;
    const isSnapshot  = /SNAPSHOT$/i.test(version);

    // URL„Éô„Éº„ÇπË®≠ÂÆö
    setupVersionUrls(version);
    const basePath    = config.image_urls[version].replace(/\/$/, '');

    // ‚ñº Áµ±ÂêàÁâà arch Ëß£Ê±∫
    const arch = await resolveArch(version, targetPath /*, { profilesData: Êó¢„Å´ÊåÅ„Å£„Å¶„ÅÑ„Çå„Å∞Ê∏°„Åô } */);
    if (!arch) {
        console.error('[fetchDevicePackages] Unable to resolve arch for target:', targetPath);
        if (typeof generatePackageSelector === 'function') generatePackageSelector();
        return;
    }

    const feeds = ["base", "luci", "packages", "routing", "telephony"];
    const urls  = [];

    if (isSnapshot) {
        feeds.forEach(feed => {
            urls.push(`${basePath}/packages/${arch}/${feed}/index.json`);
        });
        if (app.kernelHash) {
            urls.push(`${basePath}/targets/${targetPath}/kmods/${app.kernelHash}/index.json`);
        }
    } else {
        urls.push(`${basePath}/targets/${targetPath}/packages/Packages`);
        if (app.kernelHash) {
            urls.push(`${basePath}/targets/${targetPath}/kmods/${app.kernelHash}/Packages`);
        }
        feeds.forEach(feed => {
            urls.push(`${basePath}/packages/${arch}/${feed}/Packages`);
        });
    }

    const allPkgsMap = new Map();

    await Promise.allSettled(urls.map(async (url) => {
        try {
            const res = await fetch(url, { cache: 'no-cache', credentials: 'omit', mode: 'cors' });
            if (!res.ok) {
                console.warn(`Package fetch ${res.status}: ${url}`);
                return;
            }
            if (url.endsWith('.json')) {
                const data = await res.json();
                const packages = data?.packages || {};
                Object.entries(packages).forEach(([name, info]) => {
                    allPkgsMap.set(name, { name, ...info, source: url });
                });
                ErrorHandler.packageDebug.logFetch(url, true, Object.entries(packages).map(([n, i]) => ({ name: n, ...i })));
            } else {
                const text = await res.text();
                const packages = parsePackagesText(text, url);
                packages.forEach(pkg => allPkgsMap.set(pkg.name, pkg));
                ErrorHandler.packageDebug.logFetch(url, true, packages);
            }
        } catch (err) {
            console.warn(`Package fetch failed: ${url} -> ${err.message}`);
        }
    }));

    app.devicePackages = Array.from(allPkgsMap.values());
    ErrorHandler.packageDebug.dumpAll();

    function parsePackagesText(text, source) {
        const blocks = text.split(/\n\s*\n/);
        const pkgs = [];
        for (const blk of blocks) {
            const rec = {};
            for (const line of blk.split('\n')) {
                const m = line.match(/^([A-Za-z][A-Za-z0-9-]*):\s*(.*)$/);
                if (!m) continue;
                const key = m[1], val = m[2];
                if (key === "Package") rec.name = val.trim();
                else if (key === "Version") rec.version = val;
                else if (key === "Description") rec.description = val;
                else if (key === "Section") rec.section = val;
                else if (key === "Filename") rec.filename = val;
            }
            if (rec.name) {
                rec.source = source;
                pkgs.push(rec);
            }
        }
        return pkgs;
    }
}
        
// SNAPSHOT/Release ÂÖ±ÈÄö arch Ëß£Ê±∫
async function resolveArch(version, targetPath, opts = {}) {
    try {
        // 0) „Ç≠„É£„ÉÉ„Ç∑„É•ÂÑ™ÂÖà
        if (app.archPackagesMap && app.archPackagesMap[targetPath]) {
            return app.archPackagesMap[targetPath];
        }

        // 1) Âëº„Å≥Âá∫„ÅóÂÖÉ„Åå profilesData „ÇíÊ∏°„Åó„Å¶„Åç„ÅüÂ†¥Âêà
        if (opts.profilesData?.arch_packages) {
            const arch = opts.profilesData.arch_packages;
            app.archPackagesMap = app.archPackagesMap || {};
            app.archPackagesMap[targetPath] = arch;
            return arch;
        }

        // 2) URLÊßãÁØâ
        setupVersionUrls(version);
        const basePath = (config.image_urls && config.image_urls[version])
            ? config.image_urls[version].replace(/\/$/, '')
            : '';

        // 3) profiles.json Áõ¥Êé•ÂèÇÁÖß
        const profilesUrl = `${basePath}/targets/${targetPath}/profiles.json`;
        try {
            const res = await fetch(profilesUrl, { cache: 'no-cache', credentials: 'omit', mode: 'cors' });
            if (res.ok) {
                const meta = await res.json();
                const arch = meta?.arch_packages || '';
                if (arch) {
                    app.archPackagesMap = app.archPackagesMap || {};
                    app.archPackagesMap[targetPath] = arch;
                    return arch;
                }
            }
        } catch (e) {
            console.log(`[ARCH] profiles.json fetch failed: ${e.message}`);
        }

        // 4) overview.json Áî±Êù•„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
        if (app.archPackagesMap && app.archPackagesMap[targetPath]) {
            return app.archPackagesMap[targetPath];
        }

        return '';
    } catch (err) {
        console.error('[ARCH] unexpected error:', err);
        return '';
    }
}
        
// ==================== „Éë„ÉÉ„Ç±„Éº„Ç∏ÂÖ•Âäõ„Éú„ÉÉ„ÇØ„Çπ ====================
(function() {
    const pkgInput = document.getElementById('package-search');
    let pkgSearchTimer;

    if (pkgInput) {
        pkgInput.addEventListener('input', function(e) {
            clearTimeout(pkgSearchTimer);
            const query = e.target.value.trim().toLowerCase();

            if (query.length < 2 || !Array.isArray(app.devicePackages) || app.devicePackages.length === 0) {
                hidePackageAutocomplete();
                return;
            }

            pkgSearchTimer = setTimeout(() => {
                const matches = app.devicePackages
                    .filter(pkg => {
                        const name = (typeof pkg === 'string') ? pkg : pkg.name || '';
                        return name.toLowerCase().includes(query);
                    })
                    .sort((a, b) => {
                        const nameA = (typeof a === 'string') ? a : a.name || '';
                        const nameB = (typeof b === 'string') ? b : b.name || '';
                        if (nameA.toLowerCase() === query && nameB.toLowerCase() !== query) return -1;
                        if (nameB.toLowerCase() === query && nameA.toLowerCase() !== query) return 1;
                        return 0;
                    });

                showPackageAutocomplete(matches, pkgInput);
            }, 200);
        });

        // Á©∫„Å´„Åó„Åü„ÇâÂâäÈô§
        pkgInput.addEventListener('change', function() {
            if (!pkgInput.value.trim()) {
                const total = document.querySelectorAll('#package-search, #package-search-autocomplete input.package-search').length;
                if (total > 1 && pkgInput.parentNode) {
                    pkgInput.parentNode.removeChild(pkgInput);
                }
                syncTextareaFromBoxes();
            }
        });
    }
})();

// ==================== CommandsÂÖ•Âäõ„Éú„ÉÉ„ÇØ„Çπ ====================
(function() {
    const cmdInput = document.getElementById('command');
    if (cmdInput) {
        // ---- ÂÖ•ÂäõÁ¢∫ÂÆöÂæåÔºàIMEÁ¢∫ÂÆö„ÉªEnter„Éª„Éï„Ç©„Éº„Ç´„Çπ„Ç¢„Ç¶„ÉàÔºâ„ÅßÂèçÊò† ----
        const commitCommandValue = () => {
            const val = cmdInput.value.trim();
            if (val) {
                syncCommandsToTemplate();
                // Á©∫Ê¨Ñ„ÅåÁÑ°„Åë„Çå„Å∞ËøΩÂä†Ê¨ÑÁîüÊàêÔºà1„Å§„Å†„ÅëÔºâ
                setTimeout(() => {
                    if (!document.querySelector('#commands-autocomplete input[value=""]')) {
                        createExtraCommandBox();
                    }
                }, 100);
            } else {
                // Á©∫„ÅÆÂ†¥Âêà„ÅØÂâäÈô§Âá¶ÁêÜ
                const total = document.querySelectorAll('#command, #commands-autocomplete input.command').length;
                if (total > 1 && cmdInput.parentNode) {
                    cmdInput.parentNode.removeChild(cmdInput);
                }
                syncCommandsToTemplate();
            }
        };
        
        // change„Ç§„Éô„É≥„Éà„ÅÆ„Åø„Å´Áµ±‰∏Ä
        cmdInput.addEventListener('change', commitCommandValue);

        // Enter„Ç≠„ÉºÂá¶ÁêÜ„ÅÆ„ÅøËøΩÂä†Ôºàchange„Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´„Åï„Åõ„ÇãÔºâ
        cmdInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur(); // „Éï„Ç©„Éº„Ç´„Çπ„ÇíÂ§ñ„Åó„Å¶change„Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´
            }
        });
    }
})();

function createExtraCommandBox() {
    const host = document.getElementById('commands-autocomplete');
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.className = 'form-control command';
    newInput.placeholder = 'uci set system.@system[0].hostname=\'MyRouter\'';
    newInput.autocomplete = 'off';
    newInput.spellcheck = false;
    newInput.autocapitalize = 'off';
    newInput.dataset.extra = '1';

    // Á¢∫ÂÆöÊôÇ„ÅÆ„ÅøÂèçÊò†Ôºàinput„Ç§„Éô„É≥„ÉàÂâäÈô§Ôºâ
    const commitValue = () => {
        const val = newInput.value.trim();
        if (val) {
            syncCommandsToTemplate();
            if (!document.querySelector('#commands-autocomplete input[value=""]')) {
                createExtraCommandBox();
            }
        } else {
            if (newInput.dataset.extra === '1') {
                host.removeChild(newInput);
            }
            syncCommandsToTemplate();
        }
    };

    // change„Ç§„Éô„É≥„Éà„ÅÆ„Åø
    newInput.addEventListener('change', commitValue);

    // Enter„Ç≠„ÉºÂá¶ÁêÜ
    newInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            this.blur(); // change„Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´
        }
    });

    host.appendChild(newInput);
    newInput.focus();
}

function syncCommandsToTemplate() {
    // „É™„Ç¢„É´„Çø„Ç§„É†„Åß„ÉÜ„É≥„Éó„É¨„Éº„ÉàÊõ¥Êñ∞Ôºàaios-configÈñãÁä∂ÊÖã„ÅÆ„ÅøÔºâ
    if (document.getElementById('use-aios-config-details').open) {
        updateConfiguredTemplate();
    }
}
     
function hidePackageAutocomplete() {
    const el = document.querySelector('#package-search-autocomplete .autocomplete-items');
    if (el) el.remove();
}

function showPackageAutocomplete(matches, inputEl) {
    hidePackageAutocomplete();
    const host = document.getElementById('package-search-autocomplete');
    if (!host) return;

    const container = document.createElement('div');
    container.className = 'autocomplete-items';

    (matches || []).forEach(item => {
        const name = (typeof item === 'string') ? item : (item && item.name) || '';
        if (!name) return;
        const div = document.createElement('div');
        div.textContent = name;
        div.addEventListener('click', () => {
            inputEl.value = name;
            hidePackageAutocomplete();
            syncTextareaFromBoxes();
            // Á©∫Ê¨Ñ„ÅåÁÑ°„Åë„Çå„Å∞Ê¨°„ÅÆÊ¨Ñ„ÇíÁîüÊàê
            if (!document.querySelector('#package-search-autocomplete input[value=""]')) {
                createExtraPackageBox();
            }
        });
        container.appendChild(div);
    });

    host.appendChild(container);
}

function syncTextareaFromBoxes() {
    const extras = [];
    const mainSearch = document.getElementById('package-search');
    if (mainSearch && mainSearch.value.trim()) {
        extras.push(mainSearch.value.trim());
    }
    document.querySelectorAll('#package-search-autocomplete input.package-search').forEach(el => {
        const val = el.value.trim();
        if (val) extras.push(val);
    });
    // ÁµÇÁÇπ„É≠„Ç∏„ÉÉ„ÇØ„Å∏
    syncTemplateAndPackages({ trigger: 'manual', updatedPackages: extras });
}

function createExtraPackageBox() {
    const host = document.getElementById('package-search-autocomplete');
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.className = 'form-control package-search';
    newInput.placeholder = 'Type package name';
    newInput.autocomplete = 'off';
    newInput.spellcheck = false;
    newInput.autocapitalize = 'off';
    newInput.dataset.extra = '1'; // ËøΩÂä†Ê¨Ñ„Éï„É©„Ç∞

    // „Ç§„Éô„É≥„ÉàÁ¥ê‰ªò„ÅëÔºàÂÖÉ„Å®Âêå„ÅòÂãï„ÅçÔºãÂÆåÂÖ®‰∏ÄËá¥ÂÑ™ÂÖà„ÇΩ„Éº„ÉàÔºâ
    let timer;
    newInput.addEventListener('input', function() {
        clearTimeout(timer);
        const query = this.value.trim().toLowerCase();

        if (query.length < 2 || !Array.isArray(app.devicePackages) || app.devicePackages.length === 0) {
            hidePackageAutocomplete();
            return;
        }

        timer = setTimeout(() => {
            const matches = app.devicePackages
                .filter(pkg => {
                    const name = (typeof pkg === 'string') ? pkg : pkg.name || '';
                    return name.toLowerCase().includes(query);
                })
                .sort((a, b) => {
                    const nameA = (typeof a === 'string') ? a : a.name || '';
                    const nameB = (typeof b === 'string') ? b : b.name || '';
                    if (nameA.toLowerCase() === query && nameB.toLowerCase() !== query) return -1;
                    if (nameB.toLowerCase() === query && nameA.toLowerCase() !== query) return 1;
                    return 0;
                });

            showPackageAutocomplete(matches, newInput);
        }, 200);
    });

    newInput.addEventListener('change', function() {
        if (!this.value.trim() && this.dataset.extra === '1') {
            host.removeChild(this);
            syncTextareaFromBoxes();
        }
    });

    host.appendChild(newInput);
    newInput.focus();
}
  
document.addEventListener('click', function (e) {
    if (!e.target.closest('#package-search-autocomplete')) {
        hidePackageAutocomplete();
    }
});

    </script>
</body>

</html>
