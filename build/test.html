<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>packages.adb 署名検証（URL→DL→検証）</title>
<style>
body { font-family: monospace; padding: 20px; }
label { display:block; margin: 6px 0 2px; }
input[type="text"] { width: 100%; max-width: 960px; font-family: monospace; }
button { margin-top: 12px; padding: 6px 12px; }
#output { border: 1px solid #ccc; padding: 10px; margin-top: 16px; white-space: pre-wrap; background: #f5f5f5; min-height: 140px; }
.ok { color: green; font-weight: bold; }
.err { color: red; font-weight: bold; }
.muted { color: #666; }
</style>
<!-- 安定CDNからUMD版を先に読み込む -->
<script src="https://cdn.jsdelivr.net/npm/openpgp@5.11.3/dist/openpgp.min.js"></script>
</head>
<body>
<h1>packages.adb 署名検証</h1>

<label for="urlInput">パッケージディレクトリURL（末尾に /）</label>
<input type="text" id="urlInput" placeholder="例: https://downloads.openwrt.org/snapshots/packages/mipsel_24kc/luci/">

<label for="proxyInput" class="muted">任意: プロキシ接頭辞（必要な場合のみ。最終URL = ここ + 元URL）</label>
<input type="text" id="proxyInput" class="muted" placeholder="例: https://your-worker.example.com/proxy/">

<button id="verifyBtn">検証開始</button>
<div id="output">ここに進行ログと検証結果が出ます</div>

<script>
const out = document.getElementById('output');
function log(line, html=false) {
    if (html) out.innerHTML += line + '\n';
    else out.textContent += line + '\n';
}
function sanitizeBase(url) {
    if (!url) return '';
    return url.endsWith('/') ? url : (url + '/');
}
function buildFetchUrl(base, filename, proxyPrefix) {
    const direct = sanitizeBase(base) + filename;
    if (proxyPrefix && proxyPrefix.trim().length) {
        const p = proxyPrefix.trim();
        return (p.endsWith('/') ? p : (p + '/')) + direct;
    }
    return direct;
}
async function fetchBinary(name, url) {
    log(`[DL] ${name} → ${url}`);
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`${name} HTTP ${res.status}`);
    if (res.type === 'opaque') log(`  [!] 応答type=opaque（CORS制限の可能性）`);
    const buf = new Uint8Array(await res.arrayBuffer());
    log(`  OK ${buf.length} bytes`);
    return buf;
}
async function verifySignature(adbBytes, sigBytes, armoredPubKey) {
    const message = await openpgp.createMessage({ binary: adbBytes });
    let signature;
    try {
        signature = await openpgp.readSignature({ binarySignature: sigBytes });
    } catch {
        signature = await openpgp.readSignature({ armoredSignature: new TextDecoder().decode(sigBytes) });
    }
    const pubKey = await openpgp.readKey({ armoredKey: armoredPubKey });
    const vr = await openpgp.verify({ message, signature, verificationKeys: pubKey });
    const sig = vr.signatures[0];
    await sig.verified;
    return sig.keyID.toHex();
}

document.getElementById('verifyBtn').addEventListener('click', async () => {
    out.textContent = '--- 開始 ---\n';
    const base = document.getElementById('urlInput').value.trim();
    const proxyPrefix = document.getElementById('proxyInput').value.trim();
    if (!base) { log('エラー: URLを入力してください'); return; }
    const baseFixed = sanitizeBase(base);
    log(`[Base] ${baseFixed}`);
    if (proxyPrefix) log(`[Proxy] ${proxyPrefix}`);
    try {
        const adbBuf = await fetchBinary('packages.adb', buildFetchUrl(baseFixed, 'packages.adb', proxyPrefix));
        const sigBuf = await fetchBinary('packages.adb.sig', buildFetchUrl(baseFixed, 'packages.adb.sig', proxyPrefix));
        const ascBuf = await fetchBinary('packages.adb.asc', buildFetchUrl(baseFixed, 'packages.adb.asc', proxyPrefix));
        log('\n--- 署名検証 ---');
        const ascText = new TextDecoder().decode(ascBuf);
        const keyId = await verifySignature(adbBuf, sigBuf, ascText);
        log(`<span class="ok">✓ Signature valid (key ${keyId})</span>`, true);
    } catch (e) {
        log(`<span class="err">✗ 検証失敗: ${e.message}</span>`, true);
        if ((e.message || '').includes('Failed to fetch')) {
            log(`<span class="muted">補足: CORSでブロックされている可能性があります。必要なら任意プロキシを設定してください。</span>`, true);
        }
    }
});
</script>
</body>
</html>
