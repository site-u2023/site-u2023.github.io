<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ADB Format Key Dump (全方式同時テスト)</title>
<style>
body { font-family: monospace; padding: 20px; }
#output { border: 1px solid #ccc; padding: 10px; margin-top: 20px; white-space: pre-wrap; background: #f5f5f5; }
.ok { color: green; font-weight: bold; }
.err { color: red; font-weight: bold; }
.warn { color: orange; font-weight: bold; }
.section { margin-top: 12px; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lz4js@0.2.0/lz4.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/brotli-wasm@1.0.0/dist/brotli.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xz-decompress@1.0.0/xz-decompress.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@zstd/wasm@1.0.0/zstd.min.js"></script>
</head>
<body>
<h1>packages.adb 全方式同時テスト</h1>
<input type="file" id="fileInput" accept=".adb">
<div id="output">結果がここに表示されます</div>

<script>
function dumpHex(u8, start, length) {
    let out = '';
    for (let i = start; i < start + length && i < u8.length; i += 16) {
        out += i.toString(16).padStart(6, '0') + ': ';
        out += Array.from(u8.slice(i, i + 16)).map(b => b.toString(16).padStart(2, '0')).join(' ') + '  ';
        out += Array.from(u8.slice(i, i + 16)).map(b => (b >= 32 && b < 127) ? String.fromCharCode(b) : '.').join('');
        out += '\n';
    }
    return out;
}
function findSignature(u8, needle) {
    const sig = Array.from(needle).map(c => c.charCodeAt(0));
    for (let i = 0; i <= u8.length - sig.length; i++) {
        if (sig.every((b, k) => u8[i + k] === b)) return i;
    }
    return -1;
}
async function tryMethod(name, fn, data) {
    try {
        const out = await fn(data);
        const hit = findSignature(out, 'SQLite format 3');
        if (hit >= 0) return { name, ok: true, offset: hit, buf: out };
        return { name, ok: false };
    } catch (e) {
        return { name, ok: false };
    }
}
document.getElementById('fileInput').addEventListener('change', async e => {
    const file = e.target.files[0];
    if (!file) return;
    const buf = new Uint8Array(await file.arrayBuffer());
    const results = [];
    // Raw
    const rawHit = findSignature(buf, 'SQLite format 3');
    results.push(rawHit >= 0 ? { name: 'Raw', ok: true, offset: rawHit, buf } : { name: 'Raw', ok: false });
    // gzip
    results.push(await tryMethod('gzip', d => pako.ungzip(d), buf));
    // zlib
    results.push(await tryMethod('zlib', d => pako.inflate(d), buf));
    // LZ4
    results.push(await tryMethod('lz4', d => {
        const dec = new Uint8Array(10_000_000);
        const size = LZ4.decodeBlock(d, dec);
        return dec.slice(0, size);
    }, buf));
    // Brotli
    results.push(await tryMethod('brotli', d => BrotliDecode(d), buf));
    // XZ
    results.push(await tryMethod('xz', d => {
        const dec = XzDecompressor.decompress(d);
        return new Uint8Array(dec);
    }, buf));
    // Zstd
    results.push(await tryMethod('zstd', async d => {
        await ZstdInit();
        return ZstdSimple.decompress(d);
    }, buf));

    let html = `<strong>File:</strong> ${file.name} (${buf.length} bytes)\n`;
    results.forEach(r => {
        if (r.ok) {
            html += `<span class="ok">[✓]</span> ${r.name}: SQLite at 0x${r.offset.toString(16)}\n`;
            html += dumpHex(r.buf, r.offset, 64) + '\n';
        } else {
            html += `<span class="err">[✗]</span> ${r.name}: no SQLite\n`;
        }
    });
    document.getElementById('output').textContent = html;
});
</script>
</body>
</html>
