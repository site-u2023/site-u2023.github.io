const mapRulesData = {
  "basicMapRules": [
      {
          "brIpv6Address": "xxxx:xxxx:xxxx:xxxx::64",
          "eaBitLength": "xx",
          "ipv4Prefix": "xxx.xxx.0.0",
          "ipv4PrefixLength": "xx",
          "ipv6Prefix": "xxxx:xxxx:xxxx::",
          "ipv6PrefixLength": "xx",
          "psIdOffset": "xx"
      }
  ]
};

const dsliteRulesData = {
    "aftrRules": [
      {
        "aftrType": "transix",
        "ipv6PrefixRanges": [
          "2404:8e00::/32", "2404:8e01::/32",
          "240b:0010::/32", "240b:0011::/32", "240b:0012::/32"
        ]
      },
      {
        "aftrType": "xpass", 
        "ipv6PrefixRanges": [
          "2001:e30:1c1e::/48", "2001:e30:1c1f::/48"
        ]
      },
      {
        "aftrType": "v6option",
        "ipv6PrefixRanges": [
          "2404:8e00::/32", "2404:8e01::/32"
        ]
      }
    ]
  };

// OpenWrt timezone data mapping
const openwrtTimezones = {
  'Asia/Tokyo': 'JST-9',
};

function ipv6ToBigInt(ipv6) {
    if (typeof ipv6 !== 'string') {
      throw new Error('Invalid IPv6 format: input must be a string.');
    }
  
    let expanded = ipv6;
    if (expanded.includes('::')) {
      const parts = expanded.split('::');
      if (parts.length > 2) {
        throw new Error(`Invalid IPv6 format: multiple "::" in address ${ipv6}`);
      }
      const leftSegments = parts[0] ? parts[0].split(':').filter(p => p.length > 0) : [];
      const rightSegments = parts[1] ? parts[1].split(':').filter(p => p.length > 0) : [];
      
      const missingSegmentsCount = 8 - (leftSegments.length + rightSegments.length);
      if (missingSegmentsCount < 0) {
        throw new Error(`Invalid IPv6 format: too many segments in ${ipv6}`);
      }
      
      const middleZeros = Array(missingSegmentsCount).fill('0');
      let finalSegments = [];
      if (parts[0] && parts[0] !== "") finalSegments = finalSegments.concat(leftSegments);
      if (missingSegmentsCount > 0 || (parts[0] === '' && parts[1] === '')) { 
           finalSegments = finalSegments.concat(middleZeros);
      }
      if (parts[1] && parts[1] !== "") finalSegments = finalSegments.concat(rightSegments);
  
      if (expanded === "::") {
          finalSegments = Array(8).fill('0');
      } else if (finalSegments.length < 8) {
          if (expanded.startsWith("::")) {
               finalSegments = Array(8 - finalSegments.length).fill('0').concat(finalSegments);
          } else if (expanded.endsWith("::")) {
              finalSegments = finalSegments.concat(Array(8 - finalSegments.length).fill('0'));
          }
      }
      if (finalSegments.length === 0 && ipv6 !== "::") {
          finalSegments = Array(8).fill('0'); 
      }
      expanded = finalSegments.join(':');
    }
  
    const segments = expanded.split(':');
    if (segments.length !== 8) {
      throw new Error(`Invalid IPv6 format: ${ipv6}`);
    }
  
    let bigIntValue = 0n;
    for (const segment of segments) {
      if (!/^[0-9a-fA-F]{1,4}$/.test(segment)) {
        throw new Error(`Invalid IPv6 segment: "${segment}" in address ${ipv6}`);
      }
      bigIntValue = (bigIntValue << 16n) | BigInt(parseInt(segment, 16));
    }
    return bigIntValue;
  }
  
  function checkIPv6InRangeJS(targetIPv6, rulePrefixIPv6, rulePrefixLength) {
    try {
      const length = typeof rulePrefixLength === 'string' ? parseInt(rulePrefixLength, 10) : rulePrefixLength;
      if (isNaN(length) || length < 0 || length > 128) {
        return false;
      }
      if (length === 0) return true;
  
      const targetBigInt = ipv6ToBigInt(targetIPv6);
      const ruleBigInt = ipv6ToBigInt(rulePrefixIPv6);
      
      const shiftAmount = 128n - BigInt(length);
      const targetMasked = targetBigInt >> shiftAmount;
      const ruleMasked = ruleBigInt >> shiftAmount;
  
      return targetMasked === ruleMasked;
    } catch (e) {
      return false;
    }
  }
  
  function determineJurisdiction(ipv6) {
    const eastPrefixes = [
      { prefix: "2400:4050::", length: 32 },
      { prefix: "2400:4051::", length: 32 },
      { prefix: "2400:4052::", length: 32 },
      { prefix: "2001:380:a000::", length: 44 },
      { prefix: "2001:380:a100::", length: 44 },
      { prefix: "2001:380:a200::", length: 44 },
      { prefix: "2001:380:a300::", length: 44 }
    ];
    
    const westPrefixes = [
      { prefix: "2400:4150::", length: 32 },
      { prefix: "2400:4151::", length: 32 },
      { prefix: "2400:4152::", length: 32 },
      { prefix: "2001:380:b000::", length: 44 },
      { prefix: "2001:380:b100::", length: 44 },
      { prefix: "2001:380:b200::", length: 44 },
      { prefix: "2001:380:b300::", length: 44 }
    ];
  
    for (const rule of eastPrefixes) {
      if (checkIPv6InRangeJS(ipv6, rule.prefix, rule.length)) {
        return "east";
      }
    }
    
    for (const rule of westPrefixes) {
      if (checkIPv6InRangeJS(ipv6, rule.prefix, rule.length)) {
        return "west";
      }
    }
    
    return "east";
  }
  
  function checkDSLiteRule(ipv6) {
    if (!ipv6 || !dsliteRulesData || !dsliteRulesData.aftrRules) {
      return null;
    }
  
    for (const aftrRule of dsliteRulesData.aftrRules) {
      for (const prefixRange of aftrRule.ipv6PrefixRanges) {
        const [prefix, lengthStr] = prefixRange.split('/');
        const length = parseInt(lengthStr, 10);
        
        if (checkIPv6InRangeJS(ipv6, prefix, length)) {
          const jurisdiction = determineJurisdiction(ipv6);
          let aftrAddress;
          switch (aftrRule.aftrType) {
            case "transix":
              aftrAddress = jurisdiction === "east" ? "2404:8e00::feed:100" : "2404:8e01::feed:100";
              break;
            case "xpass":
              aftrAddress = jurisdiction === "east" ? "2001:e30:1c1e:1::1" : "2001:e30:1c1f:1::1";
              break;
            case "v6option":
              aftrAddress = jurisdiction === "east" ? "2404:8e00::feed:101" : "2404:8e01::feed:101";
              break;
            default:
              continue;
          }
          
          return {
            aftrType: aftrRule.aftrType,
            jurisdiction: jurisdiction,
            aftrIpv6Address: aftrAddress
          };
        }
      }
    }
    
    return null;
  }
  
  function checkMapERule(ipv6) {
    if (!ipv6 || !mapRulesData || !mapRulesData.basicMapRules) {
      return null;
    }
  
    for (const rule of mapRulesData.basicMapRules) {
      if (rule.ipv6Prefix && rule.ipv6PrefixLength) {
        if (checkIPv6InRangeJS(ipv6, rule.ipv6Prefix, rule.ipv6PrefixLength)) {
          return rule;
        }
      }
    }
    
    return null;
  }
  
  function derivePsidOffsetFromV4Len(ipv4PrefixLength) {
    const v4 = Number.parseInt(ipv4PrefixLength, 10);
    if (!Number.isFinite(v4)) return null;
    return 32 - v4;
  }
  
  function calculatePsidlenFromEaAndOffset(eaBitLength, psidOffsetCalc) {
    const ea = Number.parseInt(eaBitLength, 10);
    const off = Number.parseInt(psidOffsetCalc, 10);
    if (!Number.isFinite(ea) || !Number.isFinite(off)) return null;
    let psidlen = ea - off;
    if (psidlen < 0) psidlen = 0;
    if (psidlen > 16) return null;
    return psidlen;
  }
  
  function enrichMapRule(rule) {
    const calculatedOffset = derivePsidOffsetFromV4Len(rule.ipv4PrefixLength);
    if (calculatedOffset == null) return null;
    const psidlen = calculatePsidlenFromEaAndOffset(rule.eaBitLength, calculatedOffset);
    if (psidlen == null) return null;
    return {
      ...rule,
      calculatedOffset,
      psidlen
    };
  }

  // Get OpenWrt timezone string from zonename
  function getOpenwrtTimezone(zonename) {
    return openwrtTimezones[zonename] || null;
  }
  
  const noticeMessages = {
    ja: "個人情報の保存共有追跡はしません",
  };  

  function getNotice(langCode) {
    return noticeMessages[langCode] || noticeMessages["en"];
  }
  
  function selectLang(request, cf) {
    const accept = request.headers.get('Accept-Language') || '';
    if (accept) {
      const token = accept.split(',')[0].trim().toLowerCase();
      if (token) {
        if (token.startsWith('zh')) {
          if (token.includes('tw') || token.includes('hk') || token.includes('mo')) return 'zh_tw';
          return 'zh_cn';
        }
        if (token.startsWith('pt')) {
          if (token.includes('br')) return 'pt_br';
          return 'pt';
        }
        const base = token.split('-')[0];
        if (noticeMessages[base]) return base;
      }
    }
    const country = (cf && cf.country) ? cf.country.toUpperCase() : '';
    switch (country) {
      case 'JP': return 'ja';
      default: return 'en';
    }
  }
  
  export default {
    async fetch(request, env, ctx) {
      const method = request.method;
      const cf = request.cf || {};

      // CORSプリフライト対応
      if (method === 'OPTIONS') {
        return new Response(null, {
          status: 200,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Cache-Control': 'no-store'
          }
        });
      }

      // 非GETメソッド拒否
      if (method !== 'GET') {
        return new Response('Method Not Allowed', {
          status: 405,
          headers: { 'Cache-Control': 'no-store' }
        });
      }

      // IPv6/IPv4抽出
      const ipHeaders = [
        request.headers.get('CF-Connecting-IPv6'),
        request.headers.get('CF-Connecting-IP'),
        request.headers.get('X-Forwarded-For'),
        request.headers.get('X-Real-IP')
      ].filter(Boolean);

      let clientIPv6 = null;
      let clientIPv4 = null;

      for (const ip of ipHeaders.join(',').split(',').map(s => s.trim())) {
        if (!clientIPv6 && ip.includes(':')) clientIPv6 = ip;
        if (!clientIPv4 && ip.includes('.')) clientIPv4 = ip;
      }

      // DSLite / MAP-E 判定
      let aftrRule = null;
      let mapRule = null;

      if (clientIPv6) {
        aftrRule = checkDSLiteRule(clientIPv6);
        if (!aftrRule) {
          mapRule = checkMapERule(clientIPv6);
          if (mapRule) mapRule = enrichMapRule(mapRule);
        }
      }

      // AS情報構築
      const isp = cf.asOrganization || null;
      const asn = cf.asn || null;
      const as = (asn && isp) ? `AS${asn} ${isp}` : (isp || `AS${asn}` || null);

      // 言語・通知
      const lang = selectLang(request, cf);
      const notice = getNotice(lang);

      // タイムゾーン処理
      const zonename = cf.timezone || null;
      const timezone = zonename ? getOpenwrtTimezone(zonename) : null;

      // レスポンス構築
      const responsePayload = {
        notice,
        ipv4: clientIPv4 || null,
        ipv6: clientIPv6 || null,
        country: cf.country || null,
        zonename,
        timezone,
        isp,
        as,
        regionName: cf.region || null,
        region: cf.regionCode || null,
        aftr: aftrRule || null,
        mape: mapRule || null
      };

      return new Response(
        JSON.stringify(responsePayload, (k, v) => k === 'calculatedOffset' ? undefined : v, 2),
        {
          status: 200,
          headers: {
            'Content-Type': 'application/json; charset=utf-8',
            'Access-Control-Allow-Origin': '*',
            'Cache-Control': 'no-store'
          }
        }
      );
    }
  };
